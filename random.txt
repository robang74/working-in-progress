(c) 2026, Roberto A. Foglietta <roberto.foglietta@gmail.com>, CC ND-BY-NC 4.0

### rationale ##################################################################

Collecting entropy is a metaphor because only information can be "collected"
ergo stored in a precise notation like the number 123 or a string of bits. The
aim of "collecting entropy" is to have a sequence of numbers (information) which
cannot be anticipated. However, as you can imagine because that series of
numbers are stored somewhere, it is possible to anticipate because it is known.

The fundamental point is about WHO can access that information and HOW that
information is structured. The structure of information is fundamental to avoid
(or minimise) the risk that someone can guess the sequence. For example, we can
use the Fibonacci series and decide to start from a specific number of the
original series instead of 1. Unfortunately everyone that can see or guess a
single number of the series knows all the rest of the series. We can use the
Fibonacci series from N and step 2, or step N-4, or whatever, it has a
structure.

Structured information can be guessed, it is just a matter of how difficult it
is to make that guess (or given a unit of computation power per second, how many
seconds it will take). This is related to how complicated is the relationship
between a number and the number after e.g. Fibonacci(N, 4). When this
relationship is "random" and in particular "white noise random" it means that
every next 8-bit (or 16-bit, or 32-bit) of information are totally uncorrelated
with anything before and after thus the chance to guess the next 8-bit string is
1:2^8 (it cannot be more). This is randomness, white noise.

The 'drama' is about HOW to generate a random sequence of numbers from a system
that has been designed to be predictable and deterministic (and also error auto
correcting like ECC memory, for example). The "easiest" answer is having a very
sensitive thermometer (e.g. 0.00001°C precision) and collecting each dT-time the
least significant digit of temperature measuring. Each dT is a fixed and
repetitive timing and precision is a supposition plus the wires are EM emitters.
Which in practice is easier to sniff than we might suppose because extracting
"entropy" from heat requires physical work (L) or a Maxwell's devil.

Under this perspective what really matters is the predictability from the known
(so how hard is to guess from the known or plausible known) and how difficult is
to access that information (storing safety). Is it stored inside the CPU
registry? The chip is the safe boundary. Into the memory? The EM S/N of
conductive tracks between CPU and RAM is the safe boundary. In the kernel space
or in the user-land? For a local attacker, it is the root privilege in local
escalation, the safe boundary. For a remote, wait... Here is the MAIN point.

This "obscurity by randomness" is not used to protect the root password secret
only but mainly to protect the ciphering of the communications. Because a crypto
algorithm can be extremely hard to break unless guessing the seed of the random
numbers generator is easy instead. Because the idea behind the crypto-safety is
about who knows the key (a string of bits) can de/cypher the message (Enigma,
WW2) despite the algorithm for de/cypher being public (or deveiled, because
leaked).

Therefore about randomness, everything is about HOW hard it is to predict or
sniff the sequence of numbers from what we already know or can reasonably
support and check in a very short time, short enough to be useful: 1s or 1E100s?

In modern systems the CPU is a multi-core, multi-thread, multi-branch and all of
these "features" are multi-layered caches. Many tasks are running even if the
whole userland system is "doing nothing" and task preemption can kick in at any
time, creating latencies in HOW long a deterministic task takes. Because also in
complex systems it often requires a very-low latency (e.g. industry and CNC),
also these latencies aren't very unpredictable, and usually they aren't but
low.

Fortunately, the latency isn't ALWAYS the same nanoseconds precise and the
variance of a latency is its jitter, e.g. a latency in [ 80, 120 ] ns has a 20
(or 40) ns of maximum jitter. Usually, the distribution is a Bell curve so the
dt = 1ns (actual jitter) is more frequent than dt = 10ns. The main idea could be
that within [ 95, 105 ] ns the jitter distribution is almost flat so every value
in that range is almost the same probable to pop-up. When the value is read
outside that interval then it is discarded thus not stored. At the next turn it
might be discarded again and the chance of a continuous rejection which stops
the sequence has a not-zero probability to happen. But dT % 10 is always flat
when the average is 100 and the latency is 40 (T >> dT >> %dt).

A small number rests on a non-white noise number but Cauchy^2 distributed is
theoretically totally flat in terms of distribution, and also in practice when
the T >> dT >> %dt is related by a 4x or 10x rations like the LSB of 32-bit.

  https://github.com/robang74/roberto-a-foglietta/
    /blob/main/data/Tesi_Foglietta-051a.pdf (jitter)

Two functions are great to multiply "entropy": we cannot create entropy by a
determinist system but we can multiply it because we can spread that little bit
of randomness over a larger set of bits with a hash and zip algorithm.

Because the hash "diffuses" in a fast but NP-hard to recover way, and the zip
algorithm provides a nearly flat distribution of values which are "hard" to
guess when the first part of the output (the table) is lost (until the next
chunk). For example if 128Kb is the input chunk and 4x is the max compression
rate expected in a single chunk the output chunk will be 32Kb thus a 64b pick
has a great chance to fall somewhere the unpredictability is almost random
flat.

The zip algorithm provides a (1) nearly flat distribution of values which is (2)
hard to guess without knowing the encoding table by definition of "zip" itself.
A decent zip algorithm should tear down the redundancy of the input granting the
output values distribution would be nearly flat (file header apart, etc) as (1).
A decent zip algorithm whose output can be predicted once lost the encoding
table means that the zipped part is not p-flat enough and zip is very poor in
size shrinking or fidelity (e.g., it is a copy not a zipping or zeros string).

A process PT that creates a relatively large jittered latency and clogging the
CPU multi-threading management for a little while its execution thus being
scattered among internal computational pipes and caches, interrupted and
pre-empted is a great "random" generator in terms of nanoseconds fluctuation.

Thus the PT start, stop time in nanoseconds are not related in the least
significant stop digits. Express these two numbers in digits 0-9 then the string
$stop$start has the LSB randomness in the middle of the string which will be
something like: nnXnnx. Because the start can be guessed apart a few nanoseconds
but the relatively large jitter causes the LSB stop part to have many more
digits that can be considered strongly random in their nature.

Once a string which the random nature of nnXnnx is hashed the result is XXXXXX
because nobody can anymore say (once the start/stop are lost) how the randomness
has been diffused into the checksum string length, it is everywhere making each
bit totally unpredictable in the same manner (multiplication by diffusion).

If a process like the one described here is operated by the CPU microcode, it
would be safely bound by the CPU itself, a modern CPUs can be seen as very good
random generators because of their jitter unpredictability in executing tasks.

How good is this kind of random generator based on CPU arch and  microcode to be
good at providing unbreakable cryptography assuming the whole process is made at
the state of art? Who design the chip (or made the chip) and deliver the
microcode can definitely have access to every ciphered communications no matter
what.

### original function (2023) ###################################################

{
  n=$((33 + ${RANDOM:-15}%32))
  dd if=/dev/random bs=$n count=1 2>&1
  cat /proc/cmdline /proc/*stat /init*
} | pigz -$((1 + n%9))c > /dev/urandom &

### untested functions (2026) ##################################################

rafrand_zro() {
  echo $((33 + ${1:-$RANDOM}%32))
}

rafrand_ubf() {
  cmd=""; if [ -n "$1" ]; then cmd="chrt -$1"; fi; shift
  ionice -c3 $cmd stdbuf -o0 -e0 "$@"
}

rafrand_one() {
  k=$(rafrand_zro ${1:-})
  echo ${1:-} & ( set -x
    rafrand_ubf "" dd if=/dev/random bs=$k count=1 &
    rafrand_ubf "i 0" tail -n$((k*16)) /var/log/syslog & {
      for f in $(ls -1 /proc/cmdline /proc/*stat /init*)
        do rafrand_ubf "b 0" cat $f & done &
    }
  ) 2>&1
}

rafrand_two() {
  n=$(rafrand_zro ${1:-})
  m=$((9 - ${2:-$RANDOM}%9))
  rafrand_one ${3:-} |{\
    pigz -${m}cp$((4 * $(nproc))) -b32 |\
      dd bs=1 skip=$n count=64
    } 2>/dev/null
}

rafrand() {
  a=$(date +%N)
  c=$(rafrand_two | md5sum)
  b=$(date +%N)
  c=$(echo $b$a$c | md5sum | tr [0a-f-\ ] [1-9])
  a=$(echo $c | cut -c1-5)
  b=$(echo $c | cut -c6-10)
  c=$(echo $c | cut -c11-15)
  rafrand_two $c $a $b >/dev/urandom
}

### apparent issues ############################################################

1. The "tr" Command Entropy Bias

  Theoretically correct to arise a "bias issue" but that string is splitted
  in 3 parts and that parts are used as seed for other strong-level randomness
  production tasks. While the randomness seed seems very essential, the values
  used in that process are relatively small compared to the 5 digits (%32 to %3).
  Hence, it doesn't matter because reminders are those that really matter.

2. The "dd" skipping on Compressed Stream

  The variable "n" controls the read size of the compressed data and it creates
  a dependency where if the compressed output is smaller than $n (unlikely here
  but possible in other contexts), the command fails/outputs nothing.

  Which is correct, in theory. However, the main issue relies in "cat" files that
  can be void or not existent which is the reason because 2>&1 has been used to
  "at least" collect something and the "echo ${1:-}" has been added for a little
  more data because cat might partially or totally fail while /dev/random is not
  supposed to provide a lot of data but just a bit of extra-initial randomness.

  However, the shell implementation is just a PoC because the C-language is
  the way. Even in the laziest option, the shell implementation should be
  contextualised on the target system which, for example, it might not have
  "pigz" or not having a multi-thread processor but a "dumb" 32-bit micro
  which provides no significant jitters or "pigz" would be almost useless
  for the goal in that system.

### updates ####################################################################

rafrand_one:

  It spawns many processes, it uses "2>&1", "set -x", to mix by a time task
  switch unpredictable sequence different data flow which can potentially be
  interleaved "stdbuf" into a single output stream not only because task
  switching but also because output buffering suppression (or changes).

rafrand_ubf:

  Another way to introduce task switching uncertainty settings scheduling
  policy and priorities. Both should be tuned or rely on templates specific
  for the target architecture and customisable for the specific system. This
  approach has a good chance to "collect entropy" also from simpler CPUs.

  By the way, leveraging a "complex" scheduler is an assumption rather than
  just having a simply rotating tasks scheduler into the OS. However, rotating
  tasks may introduce some glitches which bring in those "stochastics" features
  we would like to have.

  It is worth to note that because of just a small portion of the zipped data
  stream is taken in account, it is hard to believe that this would have a
  practical effect unless hashing chunks would not also included into that
  data flows mixing process.

### tiny random generator ########################################################

The rafrand_tiny() leverages rafgen5sum() which produce random output by
multiplying I/O task jittering like dd output like this:

  echo | dd
  0+1 records in
  0+1 records out
  1 byte copied, 4.5698e-05 s, 21.9 kB/s

there are few randomness here because execution time varies between 4 and 8 -05s
on my tests which are 4.5 digits 5E4 combinations, less than 16 bits of "entropy"
because everything else is correlated at that 4.5 digits of information.

  rafgen5sum() {
      n=${1:-5}; echo | while let n--; do
          dd bs=1 count=1k 2>&1 | md5sum; done
  }

Since rafgen5sum() runs that dd five times, it creates a data stream with 64+ bits
of unstructured information (randomness) which is enough to fill the 128 md5sum.

  ug() { rafgen5sum; }    # 128-bit random

  ng() { { ug;ug;ug;ug; }| pigz -11cp8 | dd bs=32 skip=1 count=2 status=none; }

A more sophisticated implementation increase cut the obvious redundancy in the
sources and ensure enough data for terminating the task by the required length:

  cg() {
    n=${1:-6}; while let n--; do rafgen5sum 4 | cut -zc-32; done |\
      pigz -9cp8 | tail -c130 | head -c 128;
  }

  rafrand_tiny() {
    n=64; cg | while let n--; do dd bs=1 skip=1 count=1 status=none; done
  }

The changes are: the fixed length and collecting the last part of the zip-data.

### information density ########################################################

The "pigz -11" is peculiar because is one of the most extreme non-lossing
compression easily available. Thus is strong enough to provide a reasonable
quantisation of the information contained into chunk of data because it removes
redundancy. It adds a file header but the size is fix (10 byte) thus irrelevant.

  tg () { n=${1:-5}; echo | while let n--; do dd bs=1 count=1k 2>&1; done | $FUNC; }

  info: { tg;tg;tg;tg;tg; } | cut -d' ' -f1 | pigz -11cp8 | wc -c;  # -10b

  32ch: { tg;tg;tg;tg;tg; } | cut -c-32 | pigz -11cp8 | wc -c;      # -10b

  size: { tg;tg;tg;tg;tg; } | wc -c

The functions above are made to check the impact of the hashing function, here below:

       | file |  cat |  md5 | sha1 | sha256 | sha512 |
  byte |      |      |   16 |   20 |    32  |    64  |
  full |  10  | +210 | +122 | +144 |  +205  |  +367  |
  32ch |  10  |  n/a | +122 | +122 |  +122  |  +122  |
  size | n/a  | 1752 |  180 |  220 |   340  |   660  |
  cr%  | n/a  |  12% |  68% |  65% |   60%  |   56%  |
  ir%  | n/a  |  n/a |   1  |  85% |   59%  |   33%  |

The hash function doesn't matter provided that it is good enough as a hash function.

The hash function matters for avoid collisions in forensic signature but in terms of
diffusion has not any impact. The length of the output has impact on the size
of the output but taking this as a general principle we would use the clear text.

The numbers in the table above show that there is no advantage to use a longer
hash because in any case the total randomness injected remains the same but
diluted. Among these hash functions md5 is the simplest, sha256 has cr:ci = 1.

  hg () { n=${1:-5}; echo | while let n--; do dd bs=1 count=1k 2>&1; done; }

  h5 () { { hg;hg;hg;hg; } | sha512sum | cut -d' ' -f1; }

  cg () { { h5;h5; } | pigz -9cp8 | tail -c130 | head -c 128; }

With this set of functions above tuned for the sha512, the rafrand_tiny() is 2x
faster than using the md5sum (ca. 2.5x before its md5sum 85% optimization).

  hg () { echo | dd bs=32 count=32 2>&1; }

  h6 () { { hg; hg; } & { hg; hg; } & { hg; hg; } }

  h2 () { { h6 & h6 & h6; } | sha512sum -b | cut -d' ' -f1; }

  cg () { { h2 & h2; } | pigz -9c | tail -c130 | head -c128; }

However, the winner is the sha512 because of it scale better on a 8-core CPU due
to a multi-thread approach. In fact, the algorithm is newer and heavier but also
its implementation is better suited for modern CPUs.

Also, the sha256 alternative is fine:

  h2 () { { hg & hg; } | sha256sum | cut -d' ' -f1; }

  cg () { { h2 & h2 & h2 & h2; } | pigz -9c -J4 -p auto | tail -c130 | head -c 128; }

This variation that leverage the sha256 has cr:ci = 1 and the 8 cores parallelism
is about 4x faster than the first stable version based on md5sum.

  hg() { printf "%05d" $RANDOM; }

The above function is the reference to compare with because $RANDOM is the default
source of pseudorandom numbers. If the approach leveraging jitters is faster and/or
provide better quality "entropy" the reference test is passed: !kernel but shell!

### randomness density #########################################################

Stronger gc() variance with 2x randomness density (rnd/bit) even if the total
number of "dd" instances are are 10% less 6 x 3 x 3 < 5 x 4 x 2 but the concurrency
among the instances is uprises to 8 to 18 which clog also a 8-core CPU increasing
the jitter amplitude thus the randomness (as per unpredictability).

  hc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }              # run.33

  hs() { sha512sum | xxd -r -p; }

  hg() { { time echo | dd bs=1 count=1k; } 2>&1; }

  h4() { { hg & hg & hg & hg; } | hs; }

  h3() { { h4 & h4 & h4; } | hc -1; }      # h3( i:192 --> hc(-c+24) --> o:192 )

  cg() { { h3 & h3; } | hc -9 | hs; }

Then included time in hg() in order to add 3 digits more of randomness, at least.
By a raw estimation the single hg() call provides 26 bit of randomness x 24 calls.

Which is a particular good balance because N calls * N bit: N² >= 512 --> N = 23.
In practice over 165 bytes, only 128 are selected and trimmed down to 64 (1:1).

In this scenario 165 x 8 = 1320, and 24 x 26 = 624 but because the zip table the
first 32 (instead of 10, the file header) are providing lower randomness density.

A raw estimation indicates a need of randomness between 600 and 630 bits in total.
The main principle behind is hash and zip provide their best in diffuse and level
the values when they can work in their sweet spot 1:2 aka cr% and ci% around 50%.

-- RUN 28 ----------------------------------------------------------------------

let nr++; echo run.$nr
while sleep 0.01; do cg >> run.$nr; done &
while sleep   60; do entgr run.$nr; done

Evolution of the statistics from 62K to 360K file size using the "ent" command:

File size     :       61696 -->      359552 byte
Entropy       :    7.996529 -->    7.999392 bits per byte.
 \missing gap :    -0.04339% -->   -0.00760%
Chi square    :      296.75 -->      303.19
 \dev. freq.  :       3.71% -->       2.06%
Average       :    127.5678 -->    127.4090
 \Err. on avg.:      0.053% -->      0.071%
Monte Carlo Pi: 3.175646761 --> 3.143662912
 \Err. on Pi  :       1.08% -->       0.07%
Correlation   :   -0.006375 -->   -0.001009 (0: 100% uncorrelated)

-- RUN 36  ---------------------------------------------------------------------

entgr() { ent "$@" | grep -E "error|samples|127.5 |Entropy|exceed"; }

  Entropy = 7.999497 bits per byte.
  Chi square distribution for 363136 samples is 253.84, and randomly
  would exceed this value 50.88 percent of the times.
  Arithmetic mean value of data bytes is 127.4732 (127.5 = random).
  Monte Carlo value for Pi is 3.140808301 (error 0.02 percent).

Statistics from 'ent' clearly indicate that functions set below are better.

  ud() { ionice -c2 -n7 stdbuf -o0 -e0 dd status=none bs=1 "$@"; }      # run.38

  hc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  hs() { sha512sum | xxd -r -p; }

  hg() { { time echo | ud status=progress count=1k; } 2>&1 | ud; }

  h4() { { hg & hg & hg & hg; } | hs | ud; }

  h3() { { h4 & h4 & h4; } | hc -1 | hs | ud; }  # h3(i:192-->hc(-c+24)-->o:192)

  cg() { { h3 & h3; } | hc -9; }

"The Chaos Engine is independent of specific cryptographic primitives. While
 sha512sum (SHA-512/NSA, 2001) and pigz (DEF/LZ77, 2007) are used for performance
 and diffusion width, the system maintains high entropy density even when reverted
 to legacy primitives like md5sum (MD5/RSA, 1991) and gzip (LZ77/HC, 1992), proving
 that the stochasticity is derived from system-level task-switching jitter."

It is also 10^5 slower than reading from /dev/random. Which is fine, considering
it is a PoC in shell script written in two days of work by a solo man. It is worth
noting that it proves that good RNDG were available more than 30 years ago.

In fact, replacing the stochastics from the CPU/scheduler jitters with the NIC/network
jitters. The plus of using the CPU is that by "dd" jitters from ud(), despite they are
not collected yet, the process is capable of self-sustaining (aka producing new entropy
while it is delivering the entropy produced).

It is also a proof that can be realised in VHDL / FPGA because md5sum and gzip are way
simpler than CSPRNG, SHA-512, etc. By the way, MD5 and LM77/Huffman are for certainty
expired in terms of patents (which applies to hardware and chips) plus being exportable
"technologies / ideas". These aspects have an immense impact when a PoC needs to fulfill
those niches of the market for which world-wide exportability and low entry barriers
aren't optionals but MUST to have.

"In few word, it has hit the Strategic Trifecta of hardware design: Patent Immunity,
 Regulatory Compliance (Exportability), and Gate-Efficiency."

### rationale 2nd part #########################################################

Almost all security by ciphering is based on the principle that TRUE security
relies on fundamental uncertainty. So, supposing we have a source of fundamental
uncertainty, we will not be able to find out that it is a real fundamental
uncertainty or a tricking system that catches our attempts and shuffles the
answers. There is no way out of this dilemma, apparently.

Unless, a change of paradigma kicks in. Uncertainty is just A way to achieve
unpredictability. But in reality, classic deterministic systems can evolve in a
state for which unpredictability is a fundamental trait. Theory of chaos and
theory of the constrained systems control are complementary NOT mutually
exclusive. Keeping a system (or bringing for a little while a system) into an
unpredictability zone is possible and it is possible to verify in a useful
timeframe / delay that it is working in that zone.

A classic example is the 7 hits of a ball in a billiard game. If an attacker can
predict 7 moves but NOT the 8+ then the attacker is done. Because this means
that whatever s/he manages to hook the system, the system will get out of
predictability shortly despite any attempts of keeping under observation. It
means that when a system is hooked, it is already out of the observation scope
and the attacker is just looking at something in the past.

A move in chess is a letter, a number, another letter and another number (bare
plainly encodable in 12 bits). Let's say that 512 bits (of unpredictability) is
not an entire game but enough to check this assumption (43 chess moves vs
billiard 7-cushion). Failing in check with 64 bytes, means that 128 enter into
the scene. Useless trying on high ground of 128 bytes. If it works, it will work
at 32 or 64 bytes. That's my bold assumption and it is not so bold considering
what I wrote here. The history of physics is full of classic systems of
unpredictability running-away.

So, I am not inventing anything, just using a new way what seen from the past to
create conditions that usually people avoid like unpredictability. Curiously,
while we -- as humans -- are avoiding to face unpredictability, at the same time
we are seeking uncertainty for safety. This is a clear psychological pathema: we
run away from our fears to embrace the fundamental uncertainty as our comfort
zone and it is an illusion, orchestrated or not.

### mini test suite ############################################################

date +%F.%N; let nr++; echo run.$nr; \
while sleep 0.01; do cg || break; done >>run.$nr

First of all, data size should be collected into a file. While a complete test
would require something like 250GB a preliminary simple test can be provided
with 4MB. But it seems that two are failing and require deeper investigation.

dhtest() {
  test -n "${1:-}" || return 1
  dht="dieharder -g 201 -k 0 -f $1"
  declare -A tsmpl; tsmpl[0]=80; tsmpl[2]=1000; tsmpl[6]=12000
  for i in 0 1 2 6 8 10 15 100 101 203; do
    tsmpl[$i]=${tsmpl[$i]:-24000}
    printf "%3d -t ${tsmpl[$i]}\n" $i;
    $dht -t ${tsmpl[$i]} -d $i | grep -e "rewound" -e "[A-Z]\{3,8\}"
  done
}

Because it re-run over the same data at 4-bytes per 32-bit random numbers, the
size of the file should be 2^22 + 1, so the offset is even and it will introduce
a +1 shift for 4 rounds before repeating (16MB window repeat).

tf=run.set; cat run.[0-9]* >$tf; echo >>$tf; du -ks $tf; dhtest $tf

-- first attempt results -------------------------------------------------------

The two failures are complementary as described in this document before. Thus, the
most probable reason because they fail is the hash as ultimate stage of elaboration
while a further jitter-based scrambler should be adopted to masquerade it. Anyway,
as long as the hash is NP-hard cannot be reverted and if reverted what is found
is not the n-1 layer of a process than cannot be reverted by previous jittering
arbitrary operations. This obviously supports the idea that it might be more
predictable than a pure stochastic white noise, or simple because it is provided
in chunks of exactly 64 bytes. Or because one previous run was not strong enough.

run.set := run.28 run.29 run.3*  # run.set made appending data from 29 to run.37
3900	run.set
  0 -t 80
# The file file_input_raw was rewound 3 times
   diehard_birthdays|   0|        80|     100|0.96911308|  PASSED
  1 -t 24000
# The file file_input_raw was rewound 2 times
      diehard_operm5|   0|     24000|     100|0.17361806|  PASSED
  2 -t 1000
# The file file_input_raw was rewound 3 times
  diehard_rank_32x32|   0|      1000|     100|0.23196575|  PASSED
  6 -t 12000
        diehard_oqso|   0|     12000|     100|0.00000000|  FAILED
  8 -t 24000
diehard_count_1s_str|   0|     24000|     100|0.00000000|  FAILED
 10 -t 24000
# The file file_input_raw was rewound 2 times
 diehard_parking_lot|   0|     12000|     100|0.43595334|  PASSED
 15 -t 24000
# The file file_input_raw was rewound 2 times
        diehard_runs|   0|     24000|     100|0.10702158|  PASSED
        diehard_runs|   0|     24000|     100|0.61463637|  PASSED
100 -t 24000
# The file file_input_raw was rewound 2 times
         sts_monobit|   1|     24000|     100|0.76843735|  PASSED
101 -t 24000
# The file file_input_raw was rewound 2 times
            sts_runs|   2|     24000|     100|0.10684301|  PASSED
203 -t 24000
# The file file_input_raw was rewound 2 times
      rgb_lagged_sum|   0|     24000|     100|0.46743392|  PASSED

Due to these two failure, the bs=2^n should be avoided in favour of prime numbers
in which the 3 and 5 should also exclude then 1 (the most I/O stressful) and the
other best candidates like 7, 13 or 31. Considering speed is not a KPI here, bs=1.

### the masterchef cuisine ######################################################

Another wrong belief is that structured information in input of a deterministic
algorithm will create a structure in output, or at least, the output will
continue to carry on some characteristics of the original structure. Boiling a
fish tank will provide a fish soup, reversing this process isn't feasible.
Blender and mix fruits and milk, provide a milk-fruit smoothie, reversing this
process isn't feasible.

However, in IT the backdoor is about what if analysing the output I could
discover the "recipe" and the "ingredient" like how the blender works or which
was the fishtank population? Which is the same as asking how well the blender
and the mixer is working? Is the hash good? Are the zippers good? We know
tasting the smoothie and the taste of the smoothie can be replicated, for sure.
It is deterministic.

What is not deterministic, is the "information collected" on the surface of the
boiling bubble, the glitches of the mixer blades sound in cutting the fruit.
Those information have been collected but at the same time lost because mixed
with the soup and the smoothie. Although someone can argue that s/he can clearly
determine it is a fish soup rather than a fruit milkshake, it doesn't help.

What remains of the previous input information structure is enough to clear some
uncertainty but still does not provide a useful predictability. The watermark of
the compression, even if survived by 1-took-1-lost, isn't predictable. Saying
this is pigz compression output at "-p8 -9c" seems magical but gives nothing. In
the same manner we know how ciphers work: they keep the data secret if the
secret of the seed is kept.

Then, the military grade "white noise" is achieved using good and quick ciphers,
cipher the blender output and forget the key. Violating a safe to find a fish
soup or a milkshake recipe is worth the effort? Or it can be done the opposite,
cypher the input before blend and mix. When the blender and the mixer are
working good enough to compete with /dev/random, there is a good reason to think
that adding another NP-layer would easily reach the /dev/urandom and beyond.

Criptographics' need for randomness is a self solving problem. Create an
algorithm that while it ciphers or deciphers (risky, the input can be
manipulated by the attacker) is also creating unpredictable randomness at no
extra cost because every work (L) produces entropy so the ciphering as well,
just collect it. In fact, observing the 1-took-1-lost process it does 64 times
a "dd" which creates on the stderr the same kind of "entropy" we started from
initially.

It is a self-sustaining unpredictability engine: it makes running the wheels and
keeps "warm" the habitacle at the same time with the same fuel.

This is masterchef, not IT anymore? Right, because of the day in which "entropy"
word gets into the discourse: who said entropy, shame on them!

#### clockwork quality vs system variance ######################################

The last operation he() can be improved in terms of execution speed using perl.

  ud() { ionice -c2 -n7 nice -n19 stdbuf -o0 -e0 dd status=none bs=1 "$@"; }    # run.42

  hc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  hs() { sha512sum | xxd -r -p; }

  hx() { { cat -; date +%N; } | ud; }

  hg() { { time echo | ud status=progress count=1k; } 2>&1 | hx; }

  h1() { { hg & hg & hg; } | hc -1 | ud; }

  h9() { { h1 & h1 & h1; } | hc -9 | hs | ud; }

  he() { for i in $(seq 64); do dd status=none bs=1 skip=1 count=2; done; }

  cg() { { h9 & h9 & h9; } | he; }

Entropy = 7.997272 bits per byte.
Chi square distribution for 62638 samples is 236.23, and randomly
would exceed this value 79.47 percent of the times.
Arithmetic mean value of data bytes is 127.4066 (127.5 = random).
Monte Carlo value for Pi is 3.139381167 (error 0.07 percent).

Entropy = 7.999878 bits per byte.
Chi square distribution for 1489024 samples is 251.80, and randomly
would exceed this value 54.49 percent of the times.
Arithmetic mean value of data bytes is 127.5715 (127.5 = random).
Monte Carlo value for Pi is 3.140234517 (error 0.04 percent).

--------------------------------------------------------------------------------

hE() { for i in $(seq 64); do dd status=none bs=3 cbs=2 conv=block count=1; done; }
hE() { perl -0777 -pe 's/(..)./$1/gs'; }

--------------------------------------------------------------------------------

he() { perl -0777 -pe 's/.(..)/$1/gs'; }                                      # run.43

Entropy = 7.997349 bits per byte.
Chi square distribution for 62208 samples is 228.10, and randomly
would exceed this value 88.61 percent of the times.
Arithmetic mean value of data bytes is 127.5012 (127.5 = random).
Monte Carlo value for Pi is 3.151234568 (error 0.31 percent).

Entropy = 7.999524 bits per byte.
Chi square distribution for 362112 samples is 239.51, and randomly
would exceed this value 74.87 percent of the times.
Arithmetic mean value of data bytes is 127.5892 (127.5 = random).
Monte Carlo value for Pi is 3.142099682 (error 0.02 percent).

--------------------------------------------------------------------------------

he() { stdbuf -o0 -e0 perl -0777 -pe 's/.(..)/$1/gs'; }                         # run.44

Entropy = 7.996863 bits per byte.
Chi square distribution for 60800 samples is 261.69, and randomly
would exceed this value 37.32 percent of the times.
Arithmetic mean value of data bytes is 127.8874 (127.5 = random).
Monte Carlo value for Pi is 3.161551367 (error 0.64 percent).

Entropy = 7.999414 bits per byte.
Chi square distribution for 361984 samples is 294.07, and randomly
would exceed this value 4.67 percent of the times.
Arithmetic mean value of data bytes is 127.5741 (127.5 = random).
Monte Carlo value for Pi is 3.139333665 (error 0.07 percent).

--------------------------------------------------------------------------------

he() { stdbuf -oK -iK perl -0777 -pe 's/.(..)/$1/gs'; }                         # run.45

Entropy = 7.997080 bits per byte.
Chi square distribution for 62208 samples is 251.75, and randomly
would exceed this value 54.57 percent of the times.
Arithmetic mean value of data bytes is 127.1873 (127.5 = random).
Monte Carlo value for Pi is 3.152006173 (error 0.33 percent).

Entropy = 7.998482 bits per byte.
Chi square distribution for 132096 samples is 279.01, and randomly
would exceed this value 14.44 percent of the times.
Arithmetic mean value of data bytes is 127.2194 (127.5 = random).
Monte Carlo value for Pi is 3.142441860 (error 0.03 percent).

--------------------------------------------------------------------------------

he() { dd status=none ibs=1 | perl -0777 -pe 's/.(..)/$1/gs'; }                 # run.46

Entropy = 7.997593 bits per byte.
Chi square distribution for 61824 samples is 205.75, and randomly
would exceed this value 98.95 percent of the times.
Arithmetic mean value of data bytes is 127.5720 (127.5 = random).
Monte Carlo value for Pi is 3.145574534 (error 0.13 percent).

Entropy = 7.999219 bits per byte.
Chi square distribution for 208384 samples is 225.73, and randomly
would exceed this value 90.65 percent of the times.
Arithmetic mean value of data bytes is 127.7983 (127.5 = random).
Monte Carlo value for Pi is 3.142297725 (error 0.02 percent).

--------------------------------------------------------------------------------

pl() { h9 | perl -0777 -pe "$@"; }                                              # run.47

cg() { { pl 's/.(..)/$1/gs' & pl 's/(.).(.)/$1$2/gs' & pl 's/(..)./$1/gs'; } | ud; }

Entropy = 7.997120 bits per byte.
Chi square distribution for 61920 samples is 246.61, and randomly
would exceed this value 63.53 percent of the times.
Arithmetic mean value of data bytes is 127.4249 (127.5 = random).
Monte Carlo value for Pi is 3.108139535 (error 1.06 percent).

Entropy = 7.999359 bits per byte.
Chi square distribution for 242907 samples is 215.71, and randomly
would exceed this value 96.47 percent of the times.
Arithmetic mean value of data bytes is 127.3322 (127.5 = random).
Monte Carlo value for Pi is 3.135362118 (error 0.20 percent).

--------------------------------------------------------------------------------

he() { perl -0777 -pe 's/.(..)/$1/gs'; }                                        # run.48

cg() { ( h9 & h9 & h9; ) | he; }

Entropy = 7.997097 bits per byte.
Chi square distribution for 61696 samples is 247.74, and randomly
would exceed this value 61.59 percent of the times.
Arithmetic mean value of data bytes is 127.5363 (127.5 = random).
Monte Carlo value for Pi is 3.141412177 (error 0.01 percent).

Entropy = 7.999182 bits per byte.
Chi square distribution for 223232 samples is 253.48, and randomly
would exceed this value 51.52 percent of the times.
Arithmetic mean value of data bytes is 127.4573 (127.5 = random).
Monte Carlo value for Pi is 3.144631098 (error 0.10 percent).

--------------------------------------------------------------------------------

ud() { ionice -c2 -n7 nice -n19 stdbuf -o0 -e0 -i0 dd status=none bs=1 "$@"; }  # run.49

he() { perl -0777 -pe 's/.(..)/$1/gs'; }

cg() { { h9 & h9 & h9; } | he; }

Entropy = 7.997476 bits per byte.
Chi square distribution for 62464 samples is 218.76, and randomly
would exceed this value 95.13 percent of the times.
Arithmetic mean value of data bytes is 127.1777 (127.5 = random).
Monte Carlo value for Pi is 3.158885687 (error 0.55 percent).

--------------------------------------------------------------------------------

ud() { ionice -c2 -n7 nice -n19 stdbuf -o0 -e0 -i0 dd status=none bs=1 "$@"; }  # run.50

pl() { h9 | perl -0777 -pe "$@"; }

cg() { ( pl 's/.(..)/$1/gs' & pl 's/(.).(.)/$1$2/gs' & pl 's/(..)./$1/gs' ); }

Entropy = 7.996977 bits per byte.
Chi square distribution for 61275 samples is 257.20, and randomly
would exceed this value 44.96 percent of the times.
Arithmetic mean value of data bytes is 127.0001 (127.5 = random).
Monte Carlo value for Pi is 3.150802977 (error 0.29 percent).

--------------------------------------------------------------------------------

ud() { ionice -c2 -n7 nice -n19 stdbuf -o0 -e0 -i0 dd status=none bs=1 "$@"; }  # run.51

pl() { h9 | ionice -c2 -n7 nice -n19 stdbuf -o0 -e0 -i0 perl -0777 -pe "$@"; }

cg() { ( pl 's/.(..)/$1/gs' & pl 's/(.).(.)/$1$2/gs' & pl 's/(..)./$1/gs' ); }

Entropy = 7.997167 bits per byte.
Chi square distribution for 61146 samples is 239.43, and randomly
would exceed this value 74.99 percent of the times.
Arithmetic mean value of data bytes is 127.5780 (127.5 = random).
Monte Carlo value for Pi is 3.141203022 (error 0.01 percent).

Entropy = 7.999532 bits per byte.
Chi square distribution for 360297 samples is 233.78, and randomly
would exceed this value 82.57 percent of the times.
Arithmetic mean value of data bytes is 127.5438 (127.5 = random).
Monte Carlo value for Pi is 3.144565272 (error 0.09 percent).

Entropy = 7.999608 bits per byte.
Chi square distribution for 416928 samples is 226.32, and randomly
would exceed this value 90.17 percent of the times.
Arithmetic mean value of data bytes is 127.4259 (127.5 = random).
Monte Carlo value for Pi is 3.148917799 (error 0.23 percent).

--------------------------------------------------------------------------------

At this point it is clear that the introduction of "perl" into the chaos shell
engine created some imbalances because perl is not just a binary like others but
an interpreter. Among other factors, it predates the CPU against the I/O wait
general attitude of all the others commands.

Why? Because the shell starts first the last command at the end of the pipe,
and this is a multi-process single out pipe, thus "perl" as per the last in
pipe rules over all.

  ph() { ionice -c3 nice -n19 stdbuf -o0 -e0 -i0 "$@"; }                        # run.52

  ud() { ph dd status=none bs=1 "$@"; }

  pl() { h9 | ph perl -0777 -pe "$@"; }

  cg() { ( pl 's/.(.)(.)/$2$1/gs' & pl 's/(.).(.)/$1$2/gs' & pl 's/(.)(.)./$2$1/gs' ); }

Moreover, the last three symmetric workloads get imbalanced by the middle one
which was making two replacements (2x1) instead of one double (1x2). Fixed and
added a byteswap in the first and in the third, not in the middle, for symmetry.

Is all of this make sense? Is it fragility? To answer these questions in a proper
manners we need to establish what these function sets are: a sophisticated clockwork.

In a mechanical clockwork there is no input, just output, here as well. An imbalance in
the mechanism created artifacts. Even when they do not break the overall nature of
the output, with sophisticated statistical tools is possible to see these watermarks.

Under this point of view, the #42 is the reference and the #52 seems the other
reasonable candidate. Finally, do the watermarks make the tests fail? A good question
that can be faced in pragmatic way: aggregate the outputs from all the runs from #42
and the #52. In theory, they have the same nature and aim to mash down the blocks
watermarks that make those two tests fail without any other regression.

  Entropy = 7.998822 bits per byte.
  Chi square distribution for 138933 samples is 227.03, and randomly
  would exceed this value 89.57 percent of the times.
  Arithmetic mean value of data bytes is 127.3380 (127.5 = random).
  Monte Carlo value for Pi is 3.145065861 (error 0.11 percent).

  Entropy = 7.999343 bits per byte.
  Chi square distribution for 288358 samples is 261.56, and randomly
  would exceed this value 37.54 percent of the times.
  Arithmetic mean value of data bytes is 127.3903 (127.5 = random).
  Monte Carlo value for Pi is 3.150294430 (error 0.28 percent).

  Entropy = 7.999493 bits per byte.
  Chi square distribution for 384291 samples is 269.03, and randomly
  would exceed this value 26.12 percent of the times.
  Arithmetic mean value of data bytes is 127.4673 (127.5 = random).
  Monte Carlo value for Pi is 3.144079440 (error 0.08 percent).

--------------------------------------------------------------------------------

This run includes the evolutions after the introduction of "perl" into the #42 code.

  ph() { ionice -c3 nice -n19 stdbuf -o0 -e0 -i0 "$@"; }                        # run.53

  ud() { ph dd status=none bs=1 "$@"; }

  hc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  hs() { sha512sum | xxd -r -p; }

  hx() { { cat -; date +%N; } | ud; }

  hg() { { time echo | ud status=progress count=1k; } 2>&1 | hx; }

  h1() { { hg & hg & hg; } | hc -1 | ud; }

  h9() { { h1 & h1 & h1; } | hc -9 | hs | ud; }

  pl() { h9 | ph perl -0777 -pe "$@"; }

  cg() { ( pl 's/.(.)(.)/$2$1/gs' & pl 's/(.).(.)/$1$2/gs' & pl 's/(.)(.)./$2$1/gs' ); }

  Entropy = 7.996935 bits per byte.
  Chi square distribution for 61662 samples is 259.76, and randomly
  would exceed this value 40.56 percent of the times.
  Arithmetic mean value of data bytes is 127.3414 (127.5 = random).
  Monte Carlo value for Pi is 3.153449450 (error 0.38 percent).

  Entropy = 7.998560 bits per byte.
  Chi square distribution for 139836 samples is 278.41, and randomly
  would exceed this value 15.02 percent of the times.
  Arithmetic mean value of data bytes is 127.5823 (127.5 = random).
  Monte Carlo value for Pi is 3.140307217 (error 0.04 percent).

  Entropy = 7.999242 bits per byte.
  Chi square distribution for 261870 samples is 274.40, and randomly
  would exceed this value 19.28 percent of the times.
  Arithmetic mean value of data bytes is 127.6031 (127.5 = random).
  Monte Carlo value for Pi is 3.145285829 (error 0.12 percent).

--------------------------------------------------------------------------------

Removed the byte swap inhtered from the previous integration.                   # run.54

  cg() { ( pl 's/.(.)(.)/$1$2/gs' & pl 's/(.).(.)/$1$2/gs' & pl 's/(.)(.)./$1$2/gs' ); }

  Entropy = 7.999521 bits per byte.
  Chi square distribution for 360168 samples is 238.75, and randomly
  would exceed this value 75.99 percent of the times.
  Arithmetic mean value of data bytes is 127.6702 (127.5 = random).
  Monte Carlo value for Pi is 3.126940761 (error 0.47 percent).

  Entropy = 7.999584 bits per byte.
  Chi square distribution for 439503 samples is 253.44, and randomly
  would exceed this value 51.59 percent of the times.
  Arithmetic mean value of data bytes is 127.6404 (127.5 = random).
  Monte Carlo value for Pi is 3.131139932 (error 0.33 percent).

--------------------------------------------------------------------------------

Aligned the I/O waiting schedule policy into the #42 without other changes.     # run.55

  ph() { ionice -c3 nice -n19 stdbuf -o0 -e0 -i0 "$@"; }

  ud() { ph dd status=none bs=1 "$@"; }

  hc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  hs() { sha512sum | xxd -r -p; }

  hx() { { cat -; date +%N; } | ud; }

  hg() { { time echo | ud status=progress count=1k; } 2>&1 | hx; }

  h1() { { hg & hg & hg; } | hc -1 | ud; }

  h9() { { h1 & h1 & h1; } | hc -9 | hs | ud; }

  he() { for i in $(seq 64); do dd status=none bs=1 skip=1 count=2; done; }

  cg() { { h9 & h9 & h9; } | he; }

  Entropy = 7.996953 bits per byte.
  Chi square distribution for 65710 samples is 276.48, and randomly
  would exceed this value 16.98 percent of the times.
  Arithmetic mean value of data bytes is 127.9424 (127.5 = random).
  Monte Carlo value for Pi is 3.140535111 (error 0.03 percent).

  Entropy = 7.998868 bits per byte.
  Chi square distribution for 161536 samples is 252.94, and randomly
  would exceed this value 52.46 percent of the times.
  Arithmetic mean value of data bytes is 127.5995 (127.5 = random).
  Monte Carlo value for Pi is 3.151028898 (error 0.30 percent).

--------------------------------------------------------------------------------

  he() { for i in $(seq 64); do ud skip=1 count=2; done; }                      # run.56

  Entropy = 7.996751 bits per byte.
  Chi square distribution for 61222 samples is 274.07, and randomly
  would exceed this value 19.67 percent of the times.
  Arithmetic mean value of data bytes is 127.9878 (127.5 = random).
  Monte Carlo value for Pi is 3.141428991 (error 0.01 percent).

  Entropy = 7.996778 bits per byte.
  Chi square distribution for 65812 samples is 293.32, and randomly
  would exceed this value 4.97 percent of the times.
  Arithmetic mean value of data bytes is 128.0031 (127.5 = random).
  Monte Carlo value for Pi is 3.142961342 (error 0.04 percent).

  Entropy = 7.997713 bits per byte.
  Chi square distribution for 91008 samples is 288.87, and randomly
  would exceed this value 7.11 percent of the times.
  Arithmetic mean value of data bytes is 127.7922 (127.5 = random).
  Monte Carlo value for Pi is 3.147151899 (error 0.18 percent).

--------------------------------------------------------------------------------

  ph() { ionice -c2 -n 7 nice -n19 stdbuf -o0 -e0 -i0 "$@"; }                   # run.57

  he() { for i in $(seq 64); do ud skip=1 count=2; done; }

  Entropy = 7.997226 bits per byte.
  Chi square distribution for 62082 samples is 238.16, and randomly
  would exceed this value 76.82 percent of the times.
  Arithmetic mean value of data bytes is 127.6162 (127.5 = random).
  Monte Carlo value for Pi is 3.132888760 (error 0.28 percent).

  Entropy = 7.998932 bits per byte.
  Chi square distribution for 161826 samples is 239.77, and randomly
  would exceed this value 74.50 percent of the times.
  Arithmetic mean value of data bytes is 127.3880 (127.5 = random).
  Monte Carlo value for Pi is 3.144562678 (error 0.09 percent).

  Entropy = 7.998951 bits per byte.
  Chi square distribution for 175338 samples is 255.24, and randomly
  would exceed this value 48.39 percent of the times.
  Arithmetic mean value of data bytes is 127.3931 (127.5 = random).
  Monte Carlo value for Pi is 3.143140677 (error 0.05 percent).

--------------------------------------------------------------------------------# run.58

  ud() { ionice -c2 -n7 nice -n19 stdbuf -o0 -e0 -i0 dd status=none bs=1 "$@"; }

  hc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  hs() { sha512sum | xxd -r -p; }

  hx() { { cat -; date +%N; } | ud; }

  hg() { { time echo | dd status=progress bs=1 count=1k; } 2>&1 | hx; }

  h1() { { hg & hg & hg; } | hc -1 | ud; }

  h9() { { h1 & h1 & h1; } | hc -9 | hs | ud; }

  he() { for i in $(seq 64); do dd status=none bs=1 skip=1 count=2; done; }

  cg() { { h9 & h9 & h9; } | he; }

  Entropy = 7.997129 bits per byte.
  Chi square distribution for 61184 samples is 244.34, and randomly
  would exceed this value 67.33 percent of the times.
  Arithmetic mean value of data bytes is 127.6604 (127.5 = random).
  Monte Carlo value for Pi is 3.134647445 (error 0.22 percent).

  Entropy = 7.998812 bits per byte.
  Chi square distribution for 161792 samples is 264.89, and randomly
  would exceed this value 32.21 percent of the times.
  Arithmetic mean value of data bytes is 127.4235 (127.5 = random).
  Monte Carlo value for Pi is 3.148080846 (error 0.21 percent).

  Entropy = 7.999226 bits per byte.
  Chi square distribution for 239872 samples is 257.01, and randomly
  would exceed this value 45.30 percent of the times.
  Arithmetic mean value of data bytes is 127.4084 (127.5 = random).
  Monte Carlo value for Pi is 3.146230427 (error 0.15 percent).

--------------------------------------------------------------------------------# run.59

  ud() { ionice -c2 -n7 stdbuf -o0 -e0 -i0 dd status=none bs=1 "$@"; }

  Entropy = 7.996902 bits per byte.
  Chi square distribution for 61202 samples is 261.35, and randomly
  would exceed this value 37.89 percent of the times.
  Arithmetic mean value of data bytes is 127.8528 (127.5 = random).
  Monte Carlo value for Pi is 3.147843137 (error 0.20 percent).

  Entropy = 7.997805 bits per byte.
  Chi square distribution for 94976 samples is 287.67, and randomly
  would exceed this value 7.80 percent of the times.
  Arithmetic mean value of data bytes is 127.8038 (127.5 = random).
  Monte Carlo value for Pi is 3.135510771 (error 0.19 percent).

--------------------------------------------------------------------------------# run.60

The same #42 but without the nice -n19 in the ud-dd function:

  ud() { ionice -c2 -n7 stdbuf -o0 -e0 dd status=none bs=1 "$@"; }

  Entropy = 7.997045 bits per byte.
  Chi square distribution for 61824 samples is 253.73, and randomly
  would exceed this value 51.07 percent of the times.
  Arithmetic mean value of data bytes is 127.6420 (127.5 = random).
  Monte Carlo value for Pi is 3.121506211 (error 0.64 percent).

  Entropy = 7.998922 bits per byte.
  Chi square distribution for 161280 samples is 241.05, and randomly
  would exceed this value 72.57 percent of the times.
  Arithmetic mean value of data bytes is 127.5677 (127.5 = random).
  Monte Carlo value for Pi is 3.134672619 (error 0.22 percent).

  Entropy = 7.999440 bits per byte.
  Chi square distribution for 361484 samples is 281.06, and randomly
  would exceed this value 12.58 percent of the times.
  Arithmetic mean value of data bytes is 127.3748 (127.5 = random).
  Monte Carlo value for Pi is 3.142463525 (error 0.03 percent).

  Entropy = 7.999731 bits per byte.
  Chi square distribution for 720930 samples is 269.09, and randomly
  would exceed this value 26.04 percent of the times.
  Arithmetic mean value of data bytes is 127.4533 (127.5 = random).
  Monte Carlo value for Pi is 3.143805917 (error 0.07 percent).

#### testing the output ########################################################

Collecting all the output from #42 an #60 provided two results:

- 1. check for implementation variants
- 2. simulate different system scheduling conditions

Both were essential to establish how the "clockwork" is resilient and reliable.

  for i in $(seq 42 60); do cat run.$i >> run.all; done; echo >> run.all

  $  du -ks run.all --> 6104	run.all

  $ dieharder -a -f run.all

#=============================================================================#
#            dieharder version 3.31.1 Copyright 2003 Robert G. Brown          #
#=============================================================================#
   rng_name    |           filename             |rands/second|
        mt19937|                         run.all|  9.53e+07  |
#=============================================================================#
        test_name   |ntup| tsamples |psamples|  p-value |Assessment
#=============================================================================#
   diehard_birthdays|   0|       100|     100|0.03641208|  PASSED
      diehard_operm5|   0|   1000000|     100|0.07541389|  PASSED
  diehard_rank_32x32|   0|     40000|     100|0.58548746|  PASSED
    diehard_rank_6x8|   0|    100000|     100|0.76391437|  PASSED
   diehard_bitstream|   0|   2097152|     100|0.79109933|  PASSED
        diehard_opso|   0|   2097152|     100|0.58268424|  PASSED
        diehard_oqso|   0|   2097152|     100|0.57240383|  PASSED
         diehard_dna|   0|   2097152|     100|0.77761391|  PASSED
diehard_count_1s_str|   0|    256000|     100|0.02121344|  PASSED
diehard_count_1s_byt|   0|    256000|     100|0.55294204|  PASSED
 diehard_parking_lot|   0|     12000|     100|0.19536922|  PASSED
    diehard_2dsphere|   2|      8000|     100|0.25010320|  PASSED
    diehard_3dsphere|   3|      4000|     100|0.48828522|  PASSED
     diehard_squeeze|   0|    100000|     100|0.22496051|  PASSED
        diehard_sums|   0|       100|     100|0.25081516|  PASSED
        diehard_runs|   0|    100000|     100|0.11195859|  PASSED
        diehard_runs|   0|    100000|     100|0.72451058|  PASSED
       diehard_craps|   0|    200000|     100|0.75657484|  PASSED
       diehard_craps|   0|    200000|     100|0.69991716|  PASSED
 marsaglia_tsang_gcd|   0|  10000000|     100|0.35366608|  PASSED
 marsaglia_tsang_gcd|   0|  10000000|     100|0.49730104|  PASSED
         sts_monobit|   1|    100000|     100|0.17934607|  PASSED
            sts_runs|   2|    100000|     100|0.12271631|  PASSED
          sts_serial|   1|    100000|     100|0.47265566|  PASSED
          sts_serial|   2|    100000|     100|0.44899500|  PASSED
          sts_serial|   3|    100000|     100|0.30208524|  PASSED
          sts_serial|   3|    100000|     100|0.33365487|  PASSED
          sts_serial|   4|    100000|     100|0.31276400|  PASSED
          sts_serial|   4|    100000|     100|0.39483800|  PASSED
          sts_serial|   5|    100000|     100|0.79632737|  PASSED
          sts_serial|   5|    100000|     100|0.91273095|  PASSED
          sts_serial|   6|    100000|     100|0.98321159|  PASSED
          sts_serial|   6|    100000|     100|0.74252464|  PASSED
          sts_serial|   7|    100000|     100|0.80357047|  PASSED
          sts_serial|   7|    100000|     100|0.68096563|  PASSED
          sts_serial|   8|    100000|     100|0.57482535|  PASSED
          sts_serial|   8|    100000|     100|0.43322830|  PASSED
          sts_serial|   9|    100000|     100|0.60564880|  PASSED
          sts_serial|   9|    100000|     100|0.77760478|  PASSED
          sts_serial|  10|    100000|     100|0.40345293|  PASSED
          sts_serial|  10|    100000|     100|0.84797819|  PASSED
          sts_serial|  11|    100000|     100|0.96306234|  PASSED
          sts_serial|  11|    100000|     100|0.41781615|  PASSED
          sts_serial|  12|    100000|     100|0.99022533|  PASSED
          sts_serial|  12|    100000|     100|0.88586876|  PASSED
          sts_serial|  13|    100000|     100|0.09931011|  PASSED
          sts_serial|  13|    100000|     100|0.06113278|  PASSED
          sts_serial|  14|    100000|     100|0.35490381|  PASSED
          sts_serial|  14|    100000|     100|0.96509875|  PASSED
          sts_serial|  15|    100000|     100|0.20132546|  PASSED
          sts_serial|  15|    100000|     100|0.67841577|  PASSED
          sts_serial|  16|    100000|     100|0.88190174|  PASSED
          sts_serial|  16|    100000|     100|0.44063038|  PASSED
         rgb_bitdist|   1|    100000|     100|0.04888472|  PASSED
         rgb_bitdist|   2|    100000|     100|0.98183110|  PASSED
         rgb_bitdist|   3|    100000|     100|0.75638519|  PASSED
         rgb_bitdist|   4|    100000|     100|0.08362236|  PASSED
         rgb_bitdist|   5|    100000|     100|0.72637480|  PASSED
         rgb_bitdist|   6|    100000|     100|0.23909631|  PASSED
         rgb_bitdist|   7|    100000|     100|0.59757228|  PASSED
         rgb_bitdist|   8|    100000|     100|0.30322541|  PASSED
         rgb_bitdist|   9|    100000|     100|0.46453856|  PASSED
         rgb_bitdist|  10|    100000|     100|0.28734470|  PASSED
         rgb_bitdist|  11|    100000|     100|0.17575246|  PASSED
         rgb_bitdist|  12|    100000|     100|0.39138690|  PASSED
rgb_minimum_distance|   2|     10000|    1000|0.92758471|  PASSED
rgb_minimum_distance|   3|     10000|    1000|0.18048291|  PASSED
rgb_minimum_distance|   4|     10000|    1000|0.54123563|  PASSED
rgb_minimum_distance|   5|     10000|    1000|0.83739886|  PASSED
    rgb_permutations|   2|    100000|     100|0.90566701|  PASSED
    rgb_permutations|   3|    100000|     100|0.42531076|  PASSED
    rgb_permutations|   4|    100000|     100|0.85600382|  PASSED
    rgb_permutations|   5|    100000|     100|0.98238654|  PASSED
      rgb_lagged_sum|   0|   1000000|     100|0.80110616|  PASSED
      rgb_lagged_sum|   1|   1000000|     100|0.87726417|  PASSED
      rgb_lagged_sum|   2|   1000000|     100|0.76229461|  PASSED
      rgb_lagged_sum|   3|   1000000|     100|0.39697235|  PASSED
      rgb_lagged_sum|   4|   1000000|     100|0.55630985|  PASSED
      rgb_lagged_sum|   5|   1000000|     100|0.41204561|  PASSED
      rgb_lagged_sum|   6|   1000000|     100|0.16811575|  PASSED
      rgb_lagged_sum|   7|   1000000|     100|0.38863610|  PASSED
      rgb_lagged_sum|   8|   1000000|     100|0.10192600|  PASSED
      rgb_lagged_sum|   9|   1000000|     100|0.96936129|  PASSED
      rgb_lagged_sum|  10|   1000000|     100|0.63165107|  PASSED
      rgb_lagged_sum|  11|   1000000|     100|0.18413929|  PASSED
      rgb_lagged_sum|  12|   1000000|     100|0.45008215|  PASSED
      rgb_lagged_sum|  13|   1000000|     100|0.52259112|  PASSED
      rgb_lagged_sum|  14|   1000000|     100|0.23939839|  PASSED
      rgb_lagged_sum|  15|   1000000|     100|0.46559267|  PASSED
      rgb_lagged_sum|  16|   1000000|     100|0.86193601|  PASSED
      rgb_lagged_sum|  17|   1000000|     100|0.98383304|  PASSED
      rgb_lagged_sum|  18|   1000000|     100|0.80903829|  PASSED
      rgb_lagged_sum|  19|   1000000|     100|0.62545788|  PASSED
      rgb_lagged_sum|  20|   1000000|     100|0.91031756|  PASSED
      rgb_lagged_sum|  21|   1000000|     100|0.74695393|  PASSED
      rgb_lagged_sum|  22|   1000000|     100|0.89685575|  PASSED
      rgb_lagged_sum|  23|   1000000|     100|0.30518916|  PASSED
      rgb_lagged_sum|  24|   1000000|     100|0.68648182|  PASSED
      rgb_lagged_sum|  25|   1000000|     100|0.29811632|  PASSED
      rgb_lagged_sum|  26|   1000000|     100|0.02939841|  PASSED
      rgb_lagged_sum|  27|   1000000|     100|0.27859097|  PASSED
      rgb_lagged_sum|  28|   1000000|     100|0.61193995|  PASSED
      rgb_lagged_sum|  29|   1000000|     100|0.40361452|  PASSED
      rgb_lagged_sum|  30|   1000000|     100|0.27254238|  PASSED
      rgb_lagged_sum|  31|   1000000|     100|0.46073198|  PASSED
      rgb_lagged_sum|  32|   1000000|     100|0.63546725|  PASSED
     rgb_kstest_test|   0|     10000|    1000|0.87240657|  PASSED
     dab_bytedistrib|   0|  51200000|       1|0.40002040|  PASSED
             dab_dct| 256|     50000|       1|0.70791691|  PASSED
Preparing to run test 207.  ntuple = 0
        dab_filltree|  32|  15000000|       1|0.33168953|  PASSED
        dab_filltree|  32|  15000000|       1|0.52339206|  PASSED
Preparing to run test 208.  ntuple = 0
       dab_filltree2|   0|   5000000|       1|0.17713515|  PASSED
       dab_filltree2|   1|   5000000|       1|0.99092681|  PASSED
Preparing to run test 209.  ntuple = 0
        dab_monobit2|  12|  65000000|       1|0.48313795|  PASSED

--------------------------------------------------------------------------------  # run.61

  hc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  ph() { ionice -c3 nice -n19 stdbuf -o0 -e0 -i0 "$@"; }

  ud() { ph dd status=none bs=1 "$@"; }

  hs() { sha512sum | xxd -r -p; }

  hx() { { cat -; date +%N; } | ud; }

  hg() { { time echo | ud status=progress count=1k; } 2>&1 | hx; }

  h1() { { hg & hg & hg; } | hc -1 | ud; }

  h9() { { h1 & h1 & h1; } | hc -9 | hs; }

  pl() { h9 | ph perl -0777 -pe "$@" | ud; }

  cg() { ( pl 's/.(.)(.)/$2$1/gs' & pl 's/(.).(.)/$1$2/gs' & pl 's/(.)(.)./$2$1/gs' ); }

  Entropy = 7.997021 bits per byte.
  Chi square distribution for 62307 samples is 257.83, and randomly
  would exceed this value 43.86 percent of the times.
  Arithmetic mean value of data bytes is 127.5001 (127.5 = random).
  Monte Carlo value for Pi is 3.149075501 (error 0.24 percent).

  Entropy = 7.998792 bits per byte.
  Chi square distribution for 160347 samples is 268.18, and randomly
  would exceed this value 27.31 percent of the times.
  Arithmetic mean value of data bytes is 127.4963 (127.5 = random).
  Monte Carlo value for Pi is 3.143092351 (error 0.05 percent).

--------------------------------------------------------------------------------  # run.62

The custom "prpr" command replace the equivalent scripts in "perl" used before:

  https://github.com/robang74/working-in-progress/tree/main/prpr

  ph() { ionice -c2 -n7 nice -n19 stdbuf -o0 -e0 -i0 "$@"; }

  pl() { h9 | ud | ph ./prpr "$@"; }

  cg() { ( pl -r3 -o2 & pl -r-3 -o-2 & pl -r3 -o-2; ) }

  Entropy = 7.996898 bits per byte.
  Chi square distribution for 61362 samples is 264.00, and randomly
  would exceed this value 33.60 percent of the times.
  Arithmetic mean value of data bytes is 127.5129 (127.5 = random).
  Monte Carlo value for Pi is 3.121932140 (error 0.63 percent).

  Entropy = 7.998976 bits per byte.
  Chi square distribution for 161658 samples is 229.69, and randomly
  would exceed this value 87.08 percent of the times.
  Arithmetic mean value of data bytes is 127.5707 (127.5 = random).
  Monte Carlo value for Pi is 3.118286754 (error 0.74 percent).

--------------------------------------------------------------------------------  # run.63

  h1() { { hg & hg & hg; } | hc -1 | hs | ud; }

  h9() { { h1 & h1 & h1; } | hc -9 | ud; }

  pl() { h9 | hs | ph ./prpr "$@"; }

  Entropy = 7.996735 bits per byte.
  Chi square distribution for 61866 samples is 281.50, and randomly
  would exceed this value 12.21 percent of the times.
  Arithmetic mean value of data bytes is 127.6756 (127.5 = random).
  Monte Carlo value for Pi is 3.140335564 (error 0.04 percent).

  Entropy = 7.998561 bits per byte.
  Chi square distribution for 153846 samples is 307.10, and randomly
  would exceed this value 1.41 percent of the times.
  Arithmetic mean value of data bytes is 127.3994 (127.5 = random).
  Monte Carlo value for Pi is 3.148395148 (error 0.22 percent).

--------------------------------------------------------------------------------  # run.64

  h1() { { hg & hg & hg; } | hc -1 | ud; }

  h9() { { h1 & h1 & h1; } | hc -9 | hs; }

  pl() { h9 | ph ./prpr "$@" | ud; }

Entropy = 7.997220 bits per byte.
Chi square distribution for 62370 samples is 240.71, and randomly
would exceed this value 73.08 percent of the times.
Arithmetic mean value of data bytes is 127.7253 (127.5 = random).
Monte Carlo value for Pi is 3.127657528 (error 0.44 percent).

Entropy = 7.998805 bits per byte.
Chi square distribution for 161658 samples is 268.50, and randomly
would exceed this value 26.86 percent of the times.
Arithmetic mean value of data bytes is 127.8127 (127.5 = random).
Monte Carlo value for Pi is 3.133875218 (error 0.25 percent).

Entropy = 7.999089 bits per byte.
Chi square distribution for 216090 samples is 273.23, and randomly
would exceed this value 20.66 percent of the times.
Arithmetic mean value of data bytes is 127.5338 (127.5 = random).
Monte Carlo value for Pi is 3.142912675 (error 0.04 percent).

--------------------------------------------------------------------------------  # run.65

  hc() { ph pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  ph() { ionice -c3 nice -n19 stdbuf -o0 -e0 -i0 "$@"; }

  ud() { ph dd status=none bs=1 "$@"; }

  hs() { sha512sum | xxd -r -p; }

  hx() { { cat -; date +%N; } | ud; }

  hg() { { time echo | ud status=progress count=1k; } 2>&1 | hx; }

  h1() { { hg & hg & hg; } | hc -1 | ph ./prpr "$@"; }

  h9() { h1 -r3 -o2 & h1 -r-3 -o-2 & h1 -r3 -o-2; }

  pl() { h9 | hc -9 | hs | ph ./prpr "$@"; }

  cg() { ( pl -r3 -o2 & pl -r-3 -o-2 & pl -r3 -o-2; ) }

  Entropy = 7.996968 bits per byte.
  Chi square distribution for 61362 samples is 257.44, and randomly
  would exceed this value 44.55 percent of the times.
  Arithmetic mean value of data bytes is 127.4060 (127.5 = random).
  Monte Carlo value for Pi is 3.126625599 (error 0.48 percent).

  Entropy = 7.999051 bits per byte.
  Chi square distribution for 209664 samples is 275.45, and randomly
  would exceed this value 18.10 percent of the times.
  Arithmetic mean value of data bytes is 127.5688 (127.5 = random).
  Monte Carlo value for Pi is 3.120306777 (error 0.68 percent).

--------------------------------------------------------------------------------  # run.66

  hc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  ph() { ionice -c3 nice -n19 stdbuf -o0 -e0 -i0 "$@"; }

  ud() { ph dd status=none bs=1 "$@"; }

  hs() { sha512sum | xxd -r -p; }

  hg() { { time date +%N | dd; } 2>&1 | ph dd bs=1 2>&1; }

  h1() { { hg & hg & hg & hg; } | hc -1 | hs; }

  h9() { { h1 & h1 & h1 & h1; } | hc -9 | ph ./prpr "$@"; }

  cg() { ( h9 -r3 -o2 & h9 -r-3 -o-2 & h9 -r3 -o-2; ) }

  Entropy = 7.997007 bits per byte.
  Chi square distribution for 61710 samples is 255.91, and randomly
  would exceed this value 47.21 percent of the times.
  Arithmetic mean value of data bytes is 127.6381 (127.5 = random).
  Monte Carlo value for Pi is 3.141662615 (error 0.00 percent).

  Entropy = 7.998895 bits per byte.
  Chi square distribution for 163710 samples is 250.61, and randomly
  would exceed this value 56.60 percent of the times.
  Arithmetic mean value of data bytes is 127.4714 (127.5 = random).
  Monte Carlo value for Pi is 3.143265531 (error 0.05 percent).

--------------------------------------------------------------------------------  # run.67

  ph() { ionice -c2 -n7 nice -n19 stdbuf -o0 -e0 -i0 "$@"; }

  Entropy = 7.997199 bits per byte.
  Chi square distribution for 62730 samples is 244.05, and randomly
  would exceed this value 67.81 percent of the times.
  Arithmetic mean value of data bytes is 127.3736 (127.5 = random).
  Monte Carlo value for Pi is 3.142993783 (error 0.04 percent).

  Entropy = 7.998751 bits per byte.
  Chi square distribution for 163200 samples is 282.51, and randomly
  would exceed this value 11.38 percent of the times.
  Arithmetic mean value of data bytes is 127.4889 (127.5 = random).
  Monte Carlo value for Pi is 3.125735294 (error 0.50 percent).

--------------------------------------------------------------------------------  # run.68

  hc() { nice -n19 pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  ph() { ionice -c3 stdbuf -o0 -e0 -i0 "$@"; }

  hs() { nice -n19 sha512sum | ph xxd -r -p; }

  Entropy = 7.997329 bits per byte.
  Chi square distribution for 62220 samples is 228.92, and randomly
  would exceed this value 87.83 percent of the times.
  Arithmetic mean value of data bytes is 127.6527 (127.5 = random).
  Monte Carlo value for Pi is 3.143297975 (error 0.05 percent).

  Entropy = 7.999027 bits per byte.
  Chi square distribution for 164730 samples is 222.41, and randomly
  would exceed this value 93.05 percent of the times.
  Arithmetic mean value of data bytes is 127.8872 (127.5 = random).
  Monte Carlo value for Pi is 3.136186487 (error 0.17 percent).

--------------------------------------------------------------------------------  # run.69

  hc() { nice -n19 pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  ph() { nice -n19 ionice -c3 stdbuf -o0 -e0 -i0 "$@"; }

  hs() { nice -n19 sha512sum | ph xxd -r -p; }

  Entropy = 7.997331 bits per byte.
  Chi square distribution for 60690 samples is 223.97, and randomly
  would exceed this value 91.99 percent of the times.
  Arithmetic mean value of data bytes is 127.6953 (127.5 = random).
  Monte Carlo value for Pi is 3.115373208 (error 0.83 percent).

  Entropy = 7.998930 bits per byte.
  Chi square distribution for 163710 samples is 242.51, and randomly
  would exceed this value 70.29 percent of the times.
  Arithmetic mean value of data bytes is 127.9033 (127.5 = random).
  Monte Carlo value for Pi is 3.127432655 (error 0.45 percent).

--------------------------------------------------------------------------------  # run.70

  hc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  ph() { ionice -c3 nice -n19 stdbuf -o0 -e0 -i0 "$@"; }

  hs() { sha512sum | ph xxd -r -p; }

  Entropy = 7.997088 bits per byte.
  Chi square distribution for 61200 samples is 246.22, and randomly
  would exceed this value 64.19 percent of the times.
  Arithmetic mean value of data bytes is 127.8943 (127.5 = random).
  Monte Carlo value for Pi is 3.140392157 (error 0.04 percent).

  Entropy = 7.998925 bits per byte.
  Chi square distribution for 164220 samples is 244.65, and randomly
  would exceed this value 66.82 percent of the times.
  Arithmetic mean value of data bytes is 127.7786 (127.5 = random).
  Monte Carlo value for Pi is 3.125319693 (error 0.52 percent).

--------------------------------------------------------------------------------  # run.71

The run #70 teaches a lesson: schedluing policiy uniformity in mixing is fundamental.

  pc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  pi() { ionice -c3 nice -n19 stdbuf -o0 -e0 -i0 "$@"; }

  ud() { pi dd status=none bs=1 "$@"; }

  bh() { sha512sum | xxd -r -p; }

  hg() { { time date +%N | dd; } 2>&1 | dd bs=1 2>&1 | ud; }

  h1() { { hg & hg & hg & hg; } | pc -1 | bh | ud; }

  h9() { { h1 & h1 & h1 & h1; } | pc -9 | ./prpr "$@" | ud; }

  cg() { ( h9 -r3 -o2 & h9 -r-3 -o-2 & h9 -r3 -o-2; ) }

  Entropy = 7.997058 bits per byte.
  Chi square distribution for 61710 samples is 252.43, and randomly
  would exceed this value 53.37 percent of the times.
  Arithmetic mean value of data bytes is 126.9047 (127.5 = random).
  Monte Carlo value for Pi is 3.158774915 (error 0.55 percent).

  Entropy = 7.999000 bits per byte.
  Chi square distribution for 173910 samples is 240.58, and randomly
  would exceed this value 73.27 percent of the times.
  Arithmetic mean value of data bytes is 127.2945 (127.5 = random).
  Monte Carlo value for Pi is 3.153217181 (error 0.37 percent).

--------------------------------------------------------------------------------  # run.72

  pi() { ionice -c3 nice -n19 stdbuf -o0 -e0 -i0 "$@"; }

  pc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  ud() { pi dd status=none bs=1 "$@"; }

  bh() { sha512sum | pi xxd -r -p; }

  hg() { { time date +%N | dd; } 2>&1 | pi dd bs=1 2>&1; }

  h1() { { hg & hg & hg & hg; } | pc -1 | bh; }

  h9() { { h1 & h1 & h1 & h1; } | pc -9 | pi ./prpr "$@"; }

  cg() { ( h9 -r3 -o2 & h9 -r-3 -o-2 & h9 -r3 -o-2; ) }

  Entropy = 7.997181 bits per byte.
  Chi square distribution for 64260 samples is 250.49, and randomly
  would exceed this value 56.79 percent of the times.
  Arithmetic mean value of data bytes is 126.9973 (127.5 = random).
  Monte Carlo value for Pi is 3.160410831 (error 0.60 percent).

  Entropy = 7.998924 bits per byte.
  Chi square distribution for 163710 samples is 245.24, and randomly
  would exceed this value 65.84 percent of the times.
  Arithmetic mean value of data bytes is 127.2711 (127.5 = random).
  Monte Carlo value for Pi is 3.157339197 (error 0.50 percent).

--------------------------------------------------------------------------------  # run.73

  pi() { ionice -c3 nice -n19 stdbuf -o0 -e0 -i0 "$@"; }

  pc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  ud() { pi dd status=none bs=1 "$@"; }

  bh() { sha512sum | pi xxd -r -p; }

  hg() { { time date +%N | dd; } 2>&1 | pi dd bs=1 2>&1; }

  h1() { { hg & hg & hg & hg; } | pc -1 | bh; }

  h9() { { h1 & h1 & h1 & h1; } | pc -9 | ud; }

  cg() { { h9 & h9 & h9; } | ./prpr -r-3 -o-2; }

Entropy = 7.997318 bits per byte.
Chi square distribution for 72704 samples is 268.68, and randomly
would exceed this value 26.62 percent of the times.
Arithmetic mean value of data bytes is 127.4419 (127.5 = random).
Monte Carlo value for Pi is 3.142031856 (error 0.01 percent).

Entropy = 7.998900 bits per byte.
Chi square distribution for 160256 samples is 243.83, and randomly
would exceed this value 68.16 percent of the times.
Arithmetic mean value of data bytes is 127.5601 (127.5 = random).
Monte Carlo value for Pi is 3.142161818 (error 0.02 percent).

Entropy = 7.999560 bits per byte.
Chi square distribution for 392192 samples is 239.10, and randomly
would exceed this value 75.48 percent of the times.
Arithmetic mean value of data bytes is 127.6162 (127.5 = random).
Monte Carlo value for Pi is 3.143700757 (error 0.07 percent).

--------------------------------------------------------------------------------  # run.74

  pi() { ionice -c3 nice -n19 stdbuf -o0 -e0 -i0 "$@"; }

  pc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  ud() { pi dd status=none bs=1 "$@"; }

  bh() { sha512sum | xxd -r -p | ud; }

  hg() { { time date +%N | dd; } 2>&1 | pi dd bs=1 2>&1; }

  h1() { { hg & hg & hg & hg; } | ud | pc -1 | bh; }

  h9() { { h1 & h1 & h1 & h1; } | ud | pc -9 | ud; }

  cg() { { h9 & h9 & h9; } | ud | ./prpr -r-3 -o-2; }

  Entropy = 7.997142 bits per byte.
  Chi square distribution for 61952 samples is 245.92, and randomly
  would exceed this value 64.71 percent of the times.
  Arithmetic mean value of data bytes is 128.0662 (127.5 = random).
  Monte Carlo value for Pi is 3.119031477 (error 0.72 percent).

  Entropy = 7.998806 bits per byte.
  Chi square distribution for 160256 samples is 265.49, and randomly
  would exceed this value 31.29 percent of the times.
  Arithmetic mean value of data bytes is 127.7506 (127.5 = random).
  Monte Carlo value for Pi is 3.137818713 (error 0.12 percent).

  Entropy = 7.999099 bits per byte.
  Chi square distribution for 226304 samples is 282.71, and randomly
  would exceed this value 11.23 percent of the times.
  Arithmetic mean value of data bytes is 127.6830 (127.5 = random).
  Monte Carlo value for Pi is 3.136622743 (error 0.16 percent).

--------------------------------------------------------------------------------  # run.75

  pi() { ionice -c3 nice -n19 stdbuf -o0 -e0 -i0 "$@"; }

  pc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  ud() { pi dd status=none bs=1 "$@"; }

  bh() { sha512sum | xxd -r -p; }

  dg() { pi dd bs=1 2>&1; }

  hg() { { { time date +%N | dg; } 2>&1 | dg; } | ud; }

  h1() { { hg & hg & hg; } | ud | pc -1 | bh | ud; }

  h9() { { h1 & h1 & h1; } | ud | pc -9 | ud; }

  cg() { { h9 & h9 & h9; } | ud | ./prpr -r-9 -o-8; }

  Entropy = 7.996889 bits per byte.
  Chi square distribution for 60416 samples is 260.25, and randomly
  would exceed this value 39.72 percent of the times.
  Arithmetic mean value of data bytes is 127.1647 (127.5 = random).
  Monte Carlo value for Pi is 3.144701559 (error 0.10 percent).

  Entropy = 7.998818 bits per byte.
  Chi square distribution for 161792 samples is 265.23, and randomly
  would exceed this value 31.68 percent of the times.
  Arithmetic mean value of data bytes is 127.4204 (127.5 = random).
  Monte Carlo value for Pi is 3.130576673 (error 0.35 percent).

  Entropy = 7.999336 bits per byte.
  Chi square distribution for 260096 samples is 240.07, and randomly
  would exceed this value 74.05 percent of the times.
  Arithmetic mean value of data bytes is 127.4621 (127.5 = random).
  Monte Carlo value for Pi is 3.129391681 (error 0.39 percent).

  Entropy = 7.999435 bits per byte.
  Chi square distribution for 360448 samples is 282.58, and randomly
  would exceed this value 11.33 percent of the times.
  Arithmetic mean value of data bytes is 127.5409 (127.5 = random).
  Monte Carlo value for Pi is 3.133468722 (error 0.26 percent).

  Entropy = 7.999717 bits per byte.
  Chi square distribution for 712704 samples is 279.04, and randomly
  would exceed this value 14.41 percent of the times.
  Arithmetic mean value of data bytes is 127.5394 (127.5 = random).
  Monte Carlo value for Pi is 3.137358567 (error 0.13 percent).

--------------------------------------------------------------------------------  # run.76

  pi() { ionice -c3 nice -n19 stdbuf -o0 -e0 -i0 "$@"; }

  pc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  ud() { pi dd status=none bs=1 "$@"; }

  bh() { sha512sum | xxd -r -p; }

  dg() { pi dd bs=1 2>&1; }

  hg() { { time date +%N | dg; } 2>&1 | dg; }

  h1() { { hg & hg & hg; } | ud | pc -1 | bh; }

  h9() { { h1 & h1 & h1 & h1; } | ud | pc -9; }

  cg() { { h9 & h9 & h9 & h9 & h9; } | ud | ./prpr -r-5 -o-4; }

  Entropy = 7.997466 bits per byte.
  Chi square distribution for 63488 samples is 221.83, and randomly
  would exceed this value 93.42 percent of the times.
  Arithmetic mean value of data bytes is 127.4703 (127.5 = random).
  Monte Carlo value for Pi is 3.131651073 (error 0.32 percent).

  Entropy = 7.998947 bits per byte.
  Chi square distribution for 160768 samples is 235.01, and randomly
  would exceed this value 81.05 percent of the times.
  Arithmetic mean value of data bytes is 127.5769 (127.5 = random).
  Monte Carlo value for Pi is 3.133238785 (error 0.27 percent).

  Entropy = 7.999261 bits per byte.
  Chi square distribution for 261120 samples is 267.71, and randomly
  would exceed this value 28.00 percent of the times.
  Arithmetic mean value of data bytes is 127.4560 (127.5 = random).
  Monte Carlo value for Pi is 3.143382353 (error 0.06 percent).

  Entropy = 7.999518 bits per byte.
  Chi square distribution for 359424 samples is 239.82, and randomly
  would exceed this value 74.42 percent of the times.
  Arithmetic mean value of data bytes is 127.4291 (127.5 = random).
  Monte Carlo value for Pi is 3.143095620 (error 0.05 percent).

  Entropy = 7.999583 bits per byte.
  Chi square distribution for 435200 samples is 251.72, and randomly
  would exceed this value 54.62 percent of the times.
  Arithmetic mean value of data bytes is 127.4864 (127.5 = random).
  Monte Carlo value for Pi is 3.139591634 (error 0.06 percent).

--------------------------------------------------------------------------------  # run.77

  pi() { ionice -c3 nice -n19 stdbuf -o0 -e0 -i0 "$@"; }

  pc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  ud() { pi dd status=none bs=1 "$@"; }

  bh() { sha512sum | xxd -r -p; }

  dg() { pi dd bs=1 2>&1; }

  hg() { { time date +%N | dg; } 2>&1 | dg; }

  h1() { { hg & hg; } | ud | pc -1 | bh; }

  h9() { { h1 & h1 & h1; } | ud | pc -9; }

  cg() { { h9 & h9 & h9 & h9; } | ud obs=32 | ./prpr -r-32 -o-31; }

  Entropy = 7.996931 bits per byte.
  Chi square distribution for 61008 samples is 259.50, and randomly
  would exceed this value 40.99 percent of the times.
  Arithmetic mean value of data bytes is 127.8829 (127.5 = random).
  Monte Carlo value for Pi is 3.130605822 (error 0.35 percent).

  Entropy = 7.998714 bits per byte.
  Chi square distribution for 165168 samples is 295.38, and randomly
  would exceed this value 4.18 percent of the times.
  Arithmetic mean value of data bytes is 127.5628 (127.5 = random).
  Monte Carlo value for Pi is 3.148648649 (error 0.22 percent).

  Entropy = 7.999295 bits per byte.
  Chi square distribution for 292392 samples is 286.19, and randomly
  would exceed this value 8.73 percent of the times.
  Arithmetic mean value of data bytes is 127.6946 (127.5 = random).
  Monte Carlo value for Pi is 3.132397603 (error 0.29 percent).

--------------------------------------------------------------------------------  # run.78 (ok, slow)

  pi() { ionice -c3 nice -n19 stdbuf -o0 -e0 -i0 "$@"; }

  pc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  ud() { pi dd status=none bs=1 "$@"; }

  bh() { sha512sum | xxd -r -p; }

  dg() { pi dd bs=1 2>&1; }

  hg() { { time date +%N | dg; } 2>&1 | dg; }

  h1() { { hg & hg & hg; } | ud | pc -1 | bh; }

  h9() { { h1 & h1 & h1; } | ud | pc -9; }

  cg() { { h9 & h9 & h9 & h9; } | ud obs=32 | ./prpr -r-32 -o-31; }

Entropy = 7.996980 bits per byte.
Chi square distribution for 60264 samples is 251.33, and randomly
would exceed this value 55.33 percent of the times.
Arithmetic mean value of data bytes is 128.0819 (127.5 = random).
Monte Carlo value for Pi is 3.136200717 (error 0.17 percent).

Entropy = 7.998988 bits per byte.
Chi square distribution for 159960 samples is 224.32, and randomly
would exceed this value 91.73 percent of the times.
Arithmetic mean value of data bytes is 127.8673 (127.5 = random).
Monte Carlo value for Pi is 3.137134284 (error 0.14 percent).

Entropy = 7.999515 bits per byte.
Chi square distribution for 363072 samples is 244.46, and randomly
would exceed this value 67.14 percent of the times.
Arithmetic mean value of data bytes is 127.5928 (127.5 = random).
Monte Carlo value for Pi is 3.139410365 (error 0.07 percent).

--------------------------------------------------------------------------------  # run.79

  pi() { ionice -c3 nice -n19 stdbuf -o0 -e0 -i0 "$@"; }

  pc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  ud() { pi dd status=none bs=1 "$@"; }

  bh() { sha512sum | xxd -r -p; }

  dg() { pi dd bs=1 2>&1; }

  hg() { { time date +%N | dg; } 2>&1 | dg; }

  h1() { { hg & hg; } | ud | pc -1 | bh; }

  h9() { { h1 & h1 & h1; } | ud | pc -9; }

  cg() { { h9 & h9 & h9 & h9; } | ud obs=16 | ./prpr -r-16 -o-15; }

  Entropy = 7.996781 bits per byte.
  Chi square distribution for 59760 samples is 266.16, and randomly
  would exceed this value 30.28 percent of the times.
  Arithmetic mean value of data bytes is 128.0315 (127.5 = random).
  Monte Carlo value for Pi is 3.108835341 (error 1.04 percent).

  Entropy = 7.998916 bits per byte.
  Chi square distribution for 160560 samples is 240.88, and randomly
  would exceed this value 72.82 percent of the times.
  Arithmetic mean value of data bytes is 127.8422 (127.5 = random).
  Monte Carlo value for Pi is 3.115695067 (error 0.82 percent).

  Entropy = 7.998916 bits per byte.
  Chi square distribution for 160560 samples is 240.88, and randomly
  would exceed this value 72.82 percent of the times.
  Arithmetic mean value of data bytes is 127.8422 (127.5 = random).
  Monte Carlo value for Pi is 3.115695067 (error 0.82 percent).

--------------------------------------------------------------------------------  # run.80

  pi() { ionice -c3 nice -n19 stdbuf -o0 -e0 -i0 "$@"; }

  pc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  ud() { pi dd status=none bs=1 "$@"; }

  bh() { sha512sum | xxd -r -p; }

  dg() { pi dd bs=1 2>&1; }

  hg() { { time date +%N | dg; } 2>&1 | dg; }

  h1() { { hg & hg; } | ud | pc -1 | bh; }

  h9() { { h1 & h1 & h1; } | ud | pc -9; }

  cg() { { h9 & h9 & h9 & h9; } | ud obs=8 | ./prpr -r-8 -o-7; }

  Entropy = 7.997128 bits per byte.
  Chi square distribution for 59808 samples is 237.66, and randomly
  would exceed this value 77.52 percent of the times.
  Arithmetic mean value of data bytes is 127.4405 (127.5 = random).
  Monte Carlo value for Pi is 3.124799358 (error 0.53 percent).

  Entropy = 7.999079 bits per byte.
  Chi square distribution for 161280 samples is 205.47, and randomly
  would exceed this value 98.99 percent of the times.
  Arithmetic mean value of data bytes is 127.5281 (127.5 = random).
  Monte Carlo value for Pi is 3.129166667 (error 0.40 percent).

  Entropy = 7.999334 bits per byte.
  Chi square distribution for 262752 samples is 241.90, and randomly
  would exceed this value 71.25 percent of the times.
  Arithmetic mean value of data bytes is 127.4754 (127.5 = random).
  Monte Carlo value for Pi is 3.134362441 (error 0.23 percent).

  Entropy = 7.999582 bits per byte.
  Chi square distribution for 447552 samples is 258.85, and randomly
  would exceed this value 42.11 percent of the times.
  Arithmetic mean value of data bytes is 127.5403 (127.5 = random).
  Monte Carlo value for Pi is 3.135885886 (error 0.18 percent).

  Entropy = 7.999582 bits per byte.
  Chi square distribution for 447552 samples is 258.85, and randomly
  would exceed this value 42.11 percent of the times.
  Arithmetic mean value of data bytes is 127.5403 (127.5 = random).
  Monte Carlo value for Pi is 3.135885886 (error 0.18 percent).

--------------------------------------------------------------------------------  # run.81

  pi() { ionice -c3 nice -n19 stdbuf -o0 -e0 -i0 "$@"; }

  pc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  ud() { pi dd status=none bs=1 "$@"; }

  bh() { sha512sum | xxd -r -p; }

  dg() { pi dd bs=1 2>&1; }

  hg() { { time date +%N | dg; } 2>&1 | dg; }

  h1() { { hg & hg; } | ud | pc -1 | bh; }

  h9() { { h1 & h1 & h1; } | ud obs=8 | ./prpr -r-8 -o-7 | pc -9; }

  cg() { { h9 & h9 & h9 & h9; } | ud obs=512; }

  Entropy = 7.996709 bits per byte.
  Chi square distribution for 59136 samples is 269.35, and randomly
  would exceed this value 25.68 percent of the times.
  Arithmetic mean value of data bytes is 127.4607 (127.5 = random).
  Monte Carlo value for Pi is 3.131493506 (error 0.32 percent).

  Entropy = 7.998899 bits per byte.
  Chi square distribution for 162624 samples is 248.48, and randomly
  would exceed this value 60.32 percent of the times.
  Arithmetic mean value of data bytes is 127.6602 (127.5 = random).
  Monte Carlo value for Pi is 3.123524203 (error 0.58 percent).

--------------------------------------------------------------------------------  # run.82

  h9() { { h1 & h1 & h1; } | ud obs=16 | ./prpr -r-16 -o-15 | pc -9; }

  Entropy = 7.996988 bits per byte.
  Chi square distribution for 59040 samples is 246.96, and randomly
  would exceed this value 62.95 percent of the times.
  Arithmetic mean value of data bytes is 127.6303 (127.5 = random).
  Monte Carlo value for Pi is 3.123577236 (error 0.57 percent).

  Entropy = 7.999297 bits per byte.
  Chi square distribution for 262080 samples is 255.40, and randomly
  would exceed this value 48.12 percent of the times.
  Arithmetic mean value of data bytes is 127.5738 (127.5 = random).
  Monte Carlo value for Pi is 3.142032967 (error 0.01 percent).

  Entropy = 7.999470 bits per byte.
  Chi square distribution for 362160 samples is 266.00, and randomly
  would exceed this value 30.51 percent of the times.
  Arithmetic mean value of data bytes is 127.5934 (127.5 = random).
  Monte Carlo value for Pi is 3.136050364 (error 0.18 percent).

  Entropy = 7.999970 bits per byte.
  Chi square distribution for 6247440 samples is 261.16, and randomly
  would exceed this value 38.21 percent of the times.
  Arithmetic mean value of data bytes is 127.5046 (127.5 = random).
  Monte Carlo value for Pi is 3.141143252 (error 0.01 percent).

=== testing a single run =======================================================

Testing a single run is essential because establishes if a single run can be good
enough or a mixture of several engines are needed to pass all the tests. Morover
these runs from the #60 to the #82 allowed to get deeper in understanding what's
matter for designing this clockwork in a reliable manner.

  du -ks run.all
    6104	run.all
  du -ks run.82
    6108	run.82
  cp run.82 run.82.test
  echo >> run.82.test
  dieharder -a -f run.82.test

#=============================================================================#
#            dieharder version 3.31.1 Copyright 2003 Robert G. Brown          #
#=============================================================================#
   rng_name    |           filename             |rands/second|
        mt19937|                     run.82.test|  9.65e+07  |
#=============================================================================#
        test_name   |ntup| tsamples |psamples|  p-value |Assessment
#=============================================================================#
   diehard_birthdays|   0|       100|     100|0.79402831|  PASSED
      diehard_operm5|   0|   1000000|     100|0.71445214|  PASSED
  diehard_rank_32x32|   0|     40000|     100|0.61095101|  PASSED
    diehard_rank_6x8|   0|    100000|     100|0.60132060|  PASSED
   diehard_bitstream|   0|   2097152|     100|0.89715629|  PASSED
        diehard_opso|   0|   2097152|     100|0.94215120|  PASSED
        diehard_oqso|   0|   2097152|     100|0.29602779|  PASSED
         diehard_dna|   0|   2097152|     100|0.48190839|  PASSED
diehard_count_1s_str|   0|    256000|     100|0.82721780|  PASSED
diehard_count_1s_byt|   0|    256000|     100|0.98395217|  PASSED
 diehard_parking_lot|   0|     12000|     100|0.53133973|  PASSED
    diehard_2dsphere|   2|      8000|     100|0.49171492|  PASSED
    diehard_3dsphere|   3|      4000|     100|0.73732116|  PASSED
     diehard_squeeze|   0|    100000|     100|0.83266652|  PASSED
        diehard_sums|   0|       100|     100|0.01357142|  PASSED
        diehard_runs|   0|    100000|     100|0.18874586|  PASSED
        diehard_runs|   0|    100000|     100|0.65852623|  PASSED
       diehard_craps|   0|    200000|     100|0.08233515|  PASSED
       diehard_craps|   0|    200000|     100|0.24599509|  PASSED
 marsaglia_tsang_gcd|   0|  10000000|     100|0.69352848|  PASSED
 marsaglia_tsang_gcd|   0|  10000000|     100|0.29179918|  PASSED
         sts_monobit|   1|    100000|     100|0.61131607|  PASSED
            sts_runs|   2|    100000|     100|0.27245985|  PASSED
          sts_serial|   1|    100000|     100|0.69066679|  PASSED
          sts_serial|   2|    100000|     100|0.92955129|  PASSED
          sts_serial|   3|    100000|     100|0.63620788|  PASSED
          sts_serial|   3|    100000|     100|0.53112268|  PASSED
          sts_serial|   4|    100000|     100|0.73465401|  PASSED
          sts_serial|   4|    100000|     100|0.41876151|  PASSED
          sts_serial|   5|    100000|     100|0.41861265|  PASSED
          sts_serial|   5|    100000|     100|0.47999525|  PASSED
          sts_serial|   6|    100000|     100|0.98446498|  PASSED
          sts_serial|   6|    100000|     100|0.89586149|  PASSED
          sts_serial|   7|    100000|     100|0.77490631|  PASSED
          sts_serial|   7|    100000|     100|0.31548242|  PASSED
          sts_serial|   8|    100000|     100|0.85857239|  PASSED
          sts_serial|   8|    100000|     100|0.25260445|  PASSED
          sts_serial|   9|    100000|     100|0.93752091|  PASSED
          sts_serial|   9|    100000|     100|0.70800854|  PASSED
          sts_serial|  10|    100000|     100|0.36454088|  PASSED
          sts_serial|  10|    100000|     100|0.03953376|  PASSED
          sts_serial|  11|    100000|     100|0.55823431|  PASSED
          sts_serial|  11|    100000|     100|0.87654193|  PASSED
          sts_serial|  12|    100000|     100|0.39840287|  PASSED
          sts_serial|  12|    100000|     100|0.02277808|  PASSED
          sts_serial|  13|    100000|     100|0.84689792|  PASSED
          sts_serial|  13|    100000|     100|0.94515275|  PASSED
          sts_serial|  14|    100000|     100|0.04820059|  PASSED
          sts_serial|  14|    100000|     100|0.67007095|  PASSED
          sts_serial|  15|    100000|     100|0.09711746|  PASSED
          sts_serial|  15|    100000|     100|0.23107080|  PASSED
          sts_serial|  16|    100000|     100|0.43015267|  PASSED
          sts_serial|  16|    100000|     100|0.82673110|  PASSED
         rgb_bitdist|   1|    100000|     100|0.67425615|  PASSED
         rgb_bitdist|   2|    100000|     100|0.11604944|  PASSED
         rgb_bitdist|   3|    100000|     100|0.89621067|  PASSED
         rgb_bitdist|   4|    100000|     100|0.84747709|  PASSED
         rgb_bitdist|   5|    100000|     100|0.62285474|  PASSED
         rgb_bitdist|   6|    100000|     100|0.45260658|  PASSED
         rgb_bitdist|   7|    100000|     100|0.95633476|  PASSED
         rgb_bitdist|   8|    100000|     100|0.80004092|  PASSED
         rgb_bitdist|   9|    100000|     100|0.80496350|  PASSED
         rgb_bitdist|  10|    100000|     100|0.83384598|  PASSED
         rgb_bitdist|  11|    100000|     100|0.25788647|  PASSED
         rgb_bitdist|  12|    100000|     100|0.62681258|  PASSED
rgb_minimum_distance|   2|     10000|    1000|0.33282727|  PASSED
rgb_minimum_distance|   3|     10000|    1000|0.30946444|  PASSED
rgb_minimum_distance|   4|     10000|    1000|0.71385380|  PASSED
rgb_minimum_distance|   5|     10000|    1000|0.38482735|  PASSED
    rgb_permutations|   2|    100000|     100|0.48648080|  PASSED
    rgb_permutations|   3|    100000|     100|0.58517388|  PASSED
    rgb_permutations|   4|    100000|     100|0.42293489|  PASSED
    rgb_permutations|   5|    100000|     100|0.01771197|  PASSED
      rgb_lagged_sum|   0|   1000000|     100|0.32684422|  PASSED
      rgb_lagged_sum|   1|   1000000|     100|0.97672881|  PASSED
      rgb_lagged_sum|   2|   1000000|     100|0.95760546|  PASSED
      rgb_lagged_sum|   3|   1000000|     100|0.94235441|  PASSED
      rgb_lagged_sum|   4|   1000000|     100|0.01273451|  PASSED
      rgb_lagged_sum|   5|   1000000|     100|0.99421437|  PASSED
      rgb_lagged_sum|   6|   1000000|     100|0.44014833|  PASSED
      rgb_lagged_sum|   7|   1000000|     100|0.31992919|  PASSED
      rgb_lagged_sum|   8|   1000000|     100|0.24917417|  PASSED
      rgb_lagged_sum|   9|   1000000|     100|0.54816381|  PASSED
      rgb_lagged_sum|  10|   1000000|     100|0.74219703|  PASSED
      rgb_lagged_sum|  11|   1000000|     100|0.29489454|  PASSED
      rgb_lagged_sum|  12|   1000000|     100|0.57157240|  PASSED
      rgb_lagged_sum|  13|   1000000|     100|0.64287488|  PASSED
      rgb_lagged_sum|  14|   1000000|     100|0.21561089|  PASSED
      rgb_lagged_sum|  15|   1000000|     100|0.30751482|  PASSED
      rgb_lagged_sum|  16|   1000000|     100|0.69532651|  PASSED
      rgb_lagged_sum|  17|   1000000|     100|0.96164676|  PASSED
      rgb_lagged_sum|  18|   1000000|     100|0.71544882|  PASSED
      rgb_lagged_sum|  19|   1000000|     100|0.96991998|  PASSED
      rgb_lagged_sum|  20|   1000000|     100|0.17106228|  PASSED
      rgb_lagged_sum|  21|   1000000|     100|0.85848341|  PASSED
      rgb_lagged_sum|  22|   1000000|     100|0.66455716|  PASSED
      rgb_lagged_sum|  23|   1000000|     100|0.31630262|  PASSED
      rgb_lagged_sum|  24|   1000000|     100|0.92085926|  PASSED
      rgb_lagged_sum|  25|   1000000|     100|0.71872106|  PASSED
      rgb_lagged_sum|  26|   1000000|     100|0.99338759|  PASSED
      rgb_lagged_sum|  27|   1000000|     100|0.28460591|  PASSED
      rgb_lagged_sum|  28|   1000000|     100|0.84311690|  PASSED
      rgb_lagged_sum|  29|   1000000|     100|0.74704588|  PASSED
      rgb_lagged_sum|  30|   1000000|     100|0.57720865|  PASSED
      rgb_lagged_sum|  31|   1000000|     100|0.08206929|  PASSED
      rgb_lagged_sum|  32|   1000000|     100|0.15908385|  PASSED
     rgb_kstest_test|   0|     10000|    1000|0.59953360|  PASSED
     dab_bytedistrib|   0|  51200000|       1|0.89320618|  PASSED
             dab_dct| 256|     50000|       1|0.35361675|  PASSED
Preparing to run test 207.  ntuple = 0
        dab_filltree|  32|  15000000|       1|0.43990407|  PASSED
        dab_filltree|  32|  15000000|       1|0.28307474|  PASSED
Preparing to run test 208.  ntuple = 0
       dab_filltree2|   0|   5000000|       1|0.22850674|  PASSED
       dab_filltree2|   1|   5000000|       1|0.09073751|  PASSED
Preparing to run test 209.  ntuple = 0
        dab_monobit2|  12|  65000000|       1|0.86679048|  PASSED

=== a single run but relevant ==================================================

The relevant update concludes and also summarises the investigative and
demonstrative work made up to this point.

The update is about a single run that produces a data set that passes all the
tests from the `diehardner` suite. It is not a special run, it is not a special
implementation, it is by design. A run that has been chosen among those
implementations that do not show watermarks for the clockwork which generated
the numbers (aka the chaos shell engine).

Another important aspect is that the test results show a statistical similarity
with the previous run.all test that was run over collected data from run #42 and
#60. This proves that mixture was a way to anticipate test results before
providing an implementation optimised under other aspects like speed per byte
generated.

Even an improvement of 3x in generation, it is not a breakthrough because the
kernel /dev/random can generate white noise at 10^5 times faster than the
initial implementation and dividing by 3 does not fill the gap. However, a
direct and full confrontation with /dev/random isn't fair because the last is a
product of decades, thousands of people and companies behind them working at the
state of art level while the chaos shell engine is a PoC by a solo man made in a
few days.

So, why does the Chaos Shell Engine matter? Because it shows with a practical
and functional proof of concept that randomness is not necessarily depending on
waiting events for collecting unpredictability but such unpredictability can be
generated on purpose and in transforming it in white noise, more
unpredictability is also generated thus is a self-sustaining process. This
reframes completely the scenario at its fundamentals, not just the wording.

The "magic" entropy gets out of the scene. Every data collected is information
not entropy, anymore. The uncertainty isn't the key, but unpredictability.
Therefore waiting to observe and collect data isn't anymore the only way to go
but generating is another way and it is more controllable, it can be done within
a bounded system (like a chip or part of it) that has no connection with the
external environment.

This isolation isn't even necessary for the chaos clockwork functioning but it
improves security. Because the concept of unpredictability isn't just a matter
of physics (like the biliard 7-cushion or the 3-body problem) but also a
perspective.

An attacker that should have root access can tamper /dev/random but in the local
system the privilege escalation already took place and this matters more than
tampering /dev/random. At the chip level or CPU micro firmware, the same: who
can operate or observe at that level, hasn't the need to exploit lower levels.

From this point of view unpredictability is not uncertainty anymore. The
procedure to provide numbers is deterministic but the overall process is not
because of jitters on the latencies. The main concept is mixing deterministic
information in a deterministic way but driven by jittering of the process itself.

=== testing the previous =======================================================

By the way, I have tested the collection of the runs from #61 and #81, those left
behind and created during developing a faster implementation that culminates into #82.

Testing the previous runs from #61 to #81 wasn't essential but reinforces the main
point: even those implementations that in the aim of achieving a faster production
breaks simmetries and produced biased samples set, and stop as soon as the evidence
emerged of their unability to qualify, even when merged in larger set, creates some
WEAK attention flags into the test all-PASSED. Showing a relative strong resilience
in terms of design even when its fundamental rules are broken and they has been
broken by pourpose becuase a constraint is essential to keep only if it is needed.

The chaos shell engine does not rely on fragile parameter tuning; even when its
design constraints are deliberately violated during development, the resulting
output degrades gracefully rather than catastrophically. The presence of isolated
WEAK results in run.681.all confirms that the imposed symmetry constraints are not
cosmetic, but functional: when relaxed, residual structure becomes detectable,
yet the system as a whole remains statistically stable.

  for i in $(seq 61 81); do cat run.$i >> run.681.all; done
  echo >> run.681.all
  du -ks run.681.all
    5264	run.681.all
  dieharder -a -f run.681.all

#=============================================================================#
#            dieharder version 3.31.1 Copyright 2003 Robert G. Brown          #
#=============================================================================#
   rng_name    |           filename             |rands/second|
        mt19937|                     run.681.all|  9.82e+07  |
#=============================================================================#
        test_name   |ntup| tsamples |psamples|  p-value |Assessment
#=============================================================================#
   diehard_birthdays|   0|       100|     100|0.99851167|   WEAK
      diehard_operm5|   0|   1000000|     100|0.66212393|  PASSED
  diehard_rank_32x32|   0|     40000|     100|0.81137351|  PASSED
    diehard_rank_6x8|   0|    100000|     100|0.98633442|  PASSED
   diehard_bitstream|   0|   2097152|     100|0.13531121|  PASSED
        diehard_opso|   0|   2097152|     100|0.77540186|  PASSED
        diehard_oqso|   0|   2097152|     100|0.96182275|  PASSED
         diehard_dna|   0|   2097152|     100|0.78775283|  PASSED
diehard_count_1s_str|   0|    256000|     100|0.86995033|  PASSED
diehard_count_1s_byt|   0|    256000|     100|0.96720674|  PASSED
 diehard_parking_lot|   0|     12000|     100|0.87150767|  PASSED
    diehard_2dsphere|   2|      8000|     100|0.74799072|  PASSED
    diehard_3dsphere|   3|      4000|     100|0.06156903|  PASSED
     diehard_squeeze|   0|    100000|     100|0.92431567|  PASSED
        diehard_sums|   0|       100|     100|0.00016198|   WEAK
        diehard_runs|   0|    100000|     100|0.11429580|  PASSED
        diehard_runs|   0|    100000|     100|0.23704715|  PASSED
       diehard_craps|   0|    200000|     100|0.93187786|  PASSED
       diehard_craps|   0|    200000|     100|0.75595561|  PASSED
 marsaglia_tsang_gcd|   0|  10000000|     100|0.96066686|  PASSED
 marsaglia_tsang_gcd|   0|  10000000|     100|0.57553618|  PASSED
         sts_monobit|   1|    100000|     100|0.99649071|   WEAK
            sts_runs|   2|    100000|     100|0.77963632|  PASSED
          sts_serial|   1|    100000|     100|0.96939413|  PASSED
          sts_serial|   2|    100000|     100|0.49818396|  PASSED
          sts_serial|   3|    100000|     100|0.30576225|  PASSED
          sts_serial|   3|    100000|     100|0.41740924|  PASSED
          sts_serial|   4|    100000|     100|0.03904883|  PASSED
          sts_serial|   4|    100000|     100|0.11286123|  PASSED
          sts_serial|   5|    100000|     100|0.07917344|  PASSED
          sts_serial|   5|    100000|     100|0.35949753|  PASSED
          sts_serial|   6|    100000|     100|0.00038837|   WEAK
          sts_serial|   6|    100000|     100|0.02177808|  PASSED
          sts_serial|   7|    100000|     100|0.00721382|  PASSED
          sts_serial|   7|    100000|     100|0.59941207|  PASSED
          sts_serial|   8|    100000|     100|0.15432859|  PASSED
          sts_serial|   8|    100000|     100|0.78549314|  PASSED
          sts_serial|   9|    100000|     100|0.54409161|  PASSED
          sts_serial|   9|    100000|     100|0.66477347|  PASSED
          sts_serial|  10|    100000|     100|0.76245455|  PASSED
          sts_serial|  10|    100000|     100|0.81514013|  PASSED
          sts_serial|  11|    100000|     100|0.41126269|  PASSED
          sts_serial|  11|    100000|     100|0.94817689|  PASSED
          sts_serial|  12|    100000|     100|0.70809600|  PASSED
          sts_serial|  12|    100000|     100|0.92460492|  PASSED
          sts_serial|  13|    100000|     100|0.59337641|  PASSED
          sts_serial|  13|    100000|     100|0.98273854|  PASSED
          sts_serial|  14|    100000|     100|0.31922453|  PASSED
          sts_serial|  14|    100000|     100|0.17518502|  PASSED
          sts_serial|  15|    100000|     100|0.56578050|  PASSED
          sts_serial|  15|    100000|     100|0.74774961|  PASSED
          sts_serial|  16|    100000|     100|0.65521770|  PASSED
          sts_serial|  16|    100000|     100|0.24736579|  PASSED
         rgb_bitdist|   1|    100000|     100|0.10067237|  PASSED
         rgb_bitdist|   2|    100000|     100|0.84827179|  PASSED
         rgb_bitdist|   3|    100000|     100|0.89765402|  PASSED
         rgb_bitdist|   4|    100000|     100|0.12231053|  PASSED
         rgb_bitdist|   5|    100000|     100|0.86119744|  PASSED
         rgb_bitdist|   6|    100000|     100|0.83685830|  PASSED
         rgb_bitdist|   7|    100000|     100|0.76707486|  PASSED
         rgb_bitdist|   8|    100000|     100|0.05946863|  PASSED
         rgb_bitdist|   9|    100000|     100|0.79973113|  PASSED
         rgb_bitdist|  10|    100000|     100|0.36060582|  PASSED
         rgb_bitdist|  11|    100000|     100|0.69871109|  PASSED
         rgb_bitdist|  12|    100000|     100|0.72063908|  PASSED
rgb_minimum_distance|   2|     10000|    1000|0.41454923|  PASSED
rgb_minimum_distance|   3|     10000|    1000|0.53301102|  PASSED
rgb_minimum_distance|   4|     10000|    1000|0.21278934|  PASSED
rgb_minimum_distance|   5|     10000|    1000|0.89993809|  PASSED
    rgb_permutations|   2|    100000|     100|0.44265162|  PASSED
    rgb_permutations|   3|    100000|     100|0.11003359|  PASSED
    rgb_permutations|   4|    100000|     100|0.14656091|  PASSED
    rgb_permutations|   5|    100000|     100|0.96441458|  PASSED
      rgb_lagged_sum|   0|   1000000|     100|0.98223291|  PASSED
      rgb_lagged_sum|   1|   1000000|     100|0.93457708|  PASSED
      rgb_lagged_sum|   2|   1000000|     100|0.59731913|  PASSED
      rgb_lagged_sum|   3|   1000000|     100|0.65356100|  PASSED
      rgb_lagged_sum|   4|   1000000|     100|0.13538407|  PASSED
      rgb_lagged_sum|   5|   1000000|     100|0.82167932|  PASSED
      rgb_lagged_sum|   6|   1000000|     100|0.08046151|  PASSED
      rgb_lagged_sum|   7|   1000000|     100|0.70760182|  PASSED
      rgb_lagged_sum|   8|   1000000|     100|0.80177199|  PASSED
      rgb_lagged_sum|   9|   1000000|     100|0.46696203|  PASSED
      rgb_lagged_sum|  10|   1000000|     100|0.21564463|  PASSED
      rgb_lagged_sum|  11|   1000000|     100|0.18274143|  PASSED
      rgb_lagged_sum|  12|   1000000|     100|0.19508902|  PASSED
      rgb_lagged_sum|  13|   1000000|     100|0.19018835|  PASSED
      rgb_lagged_sum|  14|   1000000|     100|0.95433505|  PASSED
      rgb_lagged_sum|  15|   1000000|     100|0.66026452|  PASSED
      rgb_lagged_sum|  16|   1000000|     100|0.37258551|  PASSED
      rgb_lagged_sum|  17|   1000000|     100|0.63345528|  PASSED
      rgb_lagged_sum|  18|   1000000|     100|0.03814203|  PASSED
      rgb_lagged_sum|  19|   1000000|     100|0.71392751|  PASSED
      rgb_lagged_sum|  20|   1000000|     100|0.93504408|  PASSED
      rgb_lagged_sum|  21|   1000000|     100|0.85808730|  PASSED
      rgb_lagged_sum|  22|   1000000|     100|0.54828993|  PASSED
      rgb_lagged_sum|  23|   1000000|     100|0.60222963|  PASSED
      rgb_lagged_sum|  24|   1000000|     100|0.20412135|  PASSED
      rgb_lagged_sum|  25|   1000000|     100|0.76910368|  PASSED
      rgb_lagged_sum|  26|   1000000|     100|0.97752266|  PASSED
      rgb_lagged_sum|  27|   1000000|     100|0.62487242|  PASSED
      rgb_lagged_sum|  28|   1000000|     100|0.87709501|  PASSED
      rgb_lagged_sum|  29|   1000000|     100|0.90928319|  PASSED
      rgb_lagged_sum|  30|   1000000|     100|0.30058101|  PASSED
      rgb_lagged_sum|  31|   1000000|     100|0.50116172|  PASSED
      rgb_lagged_sum|  32|   1000000|     100|0.88078996|  PASSED
     rgb_kstest_test|   0|     10000|    1000|0.40123902|  PASSED
     dab_bytedistrib|   0|  51200000|       1|0.42086984|  PASSED
             dab_dct| 256|     50000|       1|0.63596292|  PASSED
Preparing to run test 207.  ntuple = 0
        dab_filltree|  32|  15000000|       1|0.79644680|  PASSED
        dab_filltree|  32|  15000000|       1|0.10791348|  PASSED
Preparing to run test 208.  ntuple = 0
       dab_filltree2|   0|   5000000|       1|0.78036462|  PASSED
       dab_filltree2|   1|   5000000|       1|0.55793909|  PASSED
Preparing to run test 209.  ntuple = 0
        dab_monobit2|  12|  65000000|       1|0.91125430|  PASSED

--------------------------------------------------------------------------------  # run.83

entgr() { ent "$@" | grep -E "error|samples|127.5 |Entropy|exceed|uncorrelated"; }

Equivalent functionality but more conventional order of settings application
plus use of output-only limiting ud for mixing the streams into a single one.

  pc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  pi() { nice -n19 ionice -c3 stdbuf -o0 -e0 -i0 "$@"; }

  h1() { { hg & hg; } | ud | pc -1 | ./prpr -r-16 -o-15 | bh | ud ibs=512; }

  h9() { { h1 & h1 & h1; } | ud obs=16 | pc -9 | tail -c 192 | ud ibs=512; }

  Entropy = 7.997404 bits per byte.
  Chi square distribution for 62208 samples is 223.23, and randomly
  would exceed this value 92.50 percent of the times.
  Arithmetic mean value of data bytes is 127.6617 (127.5 = random).
  Monte Carlo value for Pi is 3.154706790 (error 0.42 percent).

  Entropy = 7.999224 bits per byte.
  Chi square distribution for 261120 samples is 281.06, and randomly
  would exceed this value 12.58 percent of the times.
  Arithmetic mean value of data bytes is 127.5401 (127.5 = random).
  Monte Carlo value for Pi is 3.147150735 (error 0.18 percent).

  Entropy = 7.999484 bits per byte.
  Chi square distribution for 362688 samples is 259.02, and randomly
  would exceed this value 41.81 percent of the times.
  Arithmetic mean value of data bytes is 127.6501 (127.5 = random).
  Monte Carlo value for Pi is 3.143197459 (error 0.05 percent).

  Entropy = 7.999918 bits per byte.
  Chi square distribution for 2198016 samples is 250.83, and randomly
  would exceed this value 56.20 percent of the times.
  Arithmetic mean value of data bytes is 127.5135 (127.5 = random).
  Monte Carlo value for Pi is 3.141924354 (error 0.01 percent).
  Serial correlation coefficient is 0.000734 (totally uncorrelated = 0.0).

--------------------------------------------------------------------------------  # run.83 (2nd part)

  Entropy = 7.999885 bits per byte.
  Chi square distribution for 1605696 samples is 256.23, and randomly
  would exceed this value 46.65 percent of the times.
  Arithmetic mean value of data bytes is 127.5190 (127.5 = random).
  Monte Carlo value for Pi is 3.147584599 (error 0.19 percent).
  Serial correlation coefficient is 0.000504 (totally uncorrelated = 0.0).

  Entropy = 7.999935 bits per byte.
  Chi square distribution for 2603904 samples is 233.65, and randomly
  would exceed this value 82.73 percent of the times.
  Arithmetic mean value of data bytes is 127.4993 (127.5 = random).
  Monte Carlo value for Pi is 3.146871774 (error 0.17 percent).
  Serial correlation coefficient is 0.000216 (totally uncorrelated = 0.0).

  Entropy = 7.999953 bits per byte.
  Chi square distribution for 3608448 samples is 237.53, and randomly
  would exceed this value 77.70 percent of the times.
  Arithmetic mean value of data bytes is 127.5161 (127.5 = random).
  Monte Carlo value for Pi is 3.145744653 (error 0.13 percent).
  Serial correlation coefficient is -0.000119 (totally uncorrelated = 0.0).

  Entropy = 7.999966 bits per byte.
  Chi square distribution for 4925568 samples is 235.45, and randomly
  would exceed this value 80.49 percent of the times.
  Arithmetic mean value of data bytes is 127.5021 (127.5 = random).
  Monte Carlo value for Pi is 3.145259998 (error 0.12 percent).
  Serial correlation coefficient is -0.000421 (totally uncorrelated = 0.0).

dieharder -a -f run.83                                      # 1st + 2nd parts #
#=============================================================================#
#            dieharder version 3.31.1 Copyright 2003 Robert G. Brown          #
#=============================================================================#
   rng_name    |           filename             |rands/second|
        mt19937|                          run.83|  1.19e+08  |
#=============================================================================#
        test_name   |ntup| tsamples |psamples|  p-value |Assessment
#=============================================================================#
          sts_serial|   8|    100000|     100|0.99928914|   WEAK
      rgb_lagged_sum|   6|   1000000|     100|0.99827572|   WEAK
      rgb_lagged_sum|  16|   1000000|     100|0.99622625|   WEAK
      rgb_lagged_sum|  23|   1000000|     100|0.00306467|   WEAK
      rgb_lagged_sum|  31|   1000000|     100|0.99952363|   WEAK

echo >> run.83; dieharder -a -f run.83                      # 1st + 2nd parts #
#=============================================================================#
#            dieharder version 3.31.1 Copyright 2003 Robert G. Brown          #
#=============================================================================#
   rng_name    |           filename             |rands/second|
        mt19937|                     run.83.test|  1.07e+08  |
#=============================================================================#
        test_name   |ntup| tsamples |psamples|  p-value |Assessment
#=============================================================================#
diehard_count_1s_byt|   0|    256000|     100|0.99746005|   WEAK
     diehard_squeeze|   0|    100000|     100|0.99517582|   WEAK

echo >> run.83; dieharder -a -f run.83           # 1st + 2nd parts (test n.2) #
#=============================================================================#
#            dieharder version 3.31.1 Copyright 2003 Robert G. Brown          #
#=============================================================================#
   rng_name    |           filename             |rands/second|
        mt19937|                     run.83.test|  1.02e+08  |
#=============================================================================#
        test_name   |ntup| tsamples |psamples|  p-value |Assessment
#=============================================================================#
    rgb_permutations|   5|    100000|     100|0.00408576|   WEAK

# run #83, only 2nd part, no ending echo
#=============================================================================#
#            dieharder version 3.31.1 Copyright 2003 Robert G. Brown          #
#=============================================================================#
   rng_name    |           filename             |rands/second|
        mt19937|                      run.83.2nd|  1.31e+08  |
#=============================================================================#
        test_name   |ntup| tsamples |psamples|  p-value |Assessment
#=============================================================================#
          sts_serial|  13|    100000|     100|0.99527623|   WEAK

================================================================================
--------------------------------------------------------------------------------  # run.84

  dg() { pi dd bs=1 2>&1; }

  hg() { { time date +%N | dg; } 2>&1 | dg; }

  pc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  pi() { nice -n19 ionice -c3 stdbuf -o0 -e0 -i0 "$@"; }

  h1() { { hg & hg; } | ud | pc -1 | bh | ud ibs=64 "$@"; }

  h9() { { h1 & h1 conv=swab & h1; } | ud obs=192 | pc -9; }

  hx() { h9 | ./prpr -r 16 -o $1 | ud ibs=180 $2; }

  hy() { h9 | ./prpr -r-16 -o-15 | ud ibs=180 $2; }

  cg() { { hx 15 conv=swab & hy & hx -15 & hy conv=swab; } | ud obs=720; }

  Entropy = 7.998753 bits per byte.
  Chi square distribution for 141120 samples is 243.36, and randomly
  would exceed this value 68.92 percent of the times.
  Arithmetic mean value of data bytes is 127.6472 (127.5 = random).
  Monte Carlo value for Pi is 3.130782313 (error 0.34 percent).
  Serial correlation coefficient is 0.004273 (totally uncorrelated = 0.0).

--------------------------------------------------------------------------------  # run.85

  h1() { hg | pc -1 | bh | ud ibs=64 "$@"; }

  h9() { { h1 & h1 conv=swab & h1 & h1 conv=swab; } | ud obs=256 | pc -9; }

  hx() { h9 | ./prpr -r 16 -o $1 | ud ibs=240 $2; }

  hy() { h9 | ./prpr -r-16 -o-15 | ud ibs=240 $2; }

  cg() { { hx 15 conv=swab & hy & hx -15 & hy conv=swab; } | ud obs=720; }

  Entropy = 7.999727 bits per byte.
  Chi square distribution for 621120 samples is 234.65, and randomly
  would exceed this value 81.50 percent of the times.
  Arithmetic mean value of data bytes is 127.4872 (127.5 = random).
  Monte Carlo value for Pi is 3.144204019 (error 0.08 percent).
  Serial correlation coefficient is -0.000597 (totally uncorrelated = 0.0).

--------------------------------------------------------------------------------  # run.86

  h9() { { h1 conv=swab & h1 & h1 & h1 conv=swab; } | ud obs=256 | pc -9; }

  hx() { h9 | ./prpr -r 16 -o $1 | ud ibs=240 $2; }

  hy() { h9 | ./prpr -r-16 -o-15 | ud ibs=240 $2; }

  cg() { { hx 15 conv=swab & hy & hx -15 & hy conv=swab; } | ud obs=720; }

  Entropy = 7.999518 bits per byte.
  Chi square distribution for 402240 samples is 268.03, and randomly
  would exceed this value 27.53 percent of the times.
  Arithmetic mean value of data bytes is 127.5538 (127.5 = random).
  Monte Carlo value for Pi is 3.141527446 (error 0.00 percent).
  Serial correlation coefficient is -0.001817 (totally uncorrelated = 0.0).

--------------------------------------------------------------------------------  # run.87

  h9() { { h1 conv=swab & h1 & h1 & h1 conv=swab; } | ud obs=256 | pc -9; }

  hx() { h9 | ./prpr -r 16 -o $1 | ud ibs=240 $2; }

  hy() { h9 | ./prpr -r-16 -o-15 | ud ibs=240 $2; }

  cg() { { hx 15 conv=swab & hy & hx -15 & hy conv=swab; } | ud obs=720; }

  Entropy = 7.999518 bits per byte.
  Chi square distribution for 402240 samples is 268.03, and randomly
  would exceed this value 27.53 percent of the times.
  Arithmetic mean value of data bytes is 127.5538 (127.5 = random).
  Monte Carlo value for Pi is 3.141527446 (error 0.00 percent).
  Serial correlation coefficient is -0.001817 (totally uncorrelated = 0.0).

--------------------------------------------------------------------------------  # run.88

  h9() { { h1 & h1 & h1 & h1; }  | ud obs=256 | pc -9; }

  hx() { h9 | ./prpr -r 16 -o $1 | ud ibs=240 $2; }

  hy() { h9 | ./prpr -r-16 -o-15 | ud ibs=240 $2; }

  cg() { { hy & hx 15 conv=swab & hx -15 & hy conv=swab; } | ud obs=960; }

  Entropy = 7.999576 bits per byte.
  Chi square distribution for 391680 samples is 230.36, and randomly
  would exceed this value 86.40 percent of the times.
  Arithmetic mean value of data bytes is 127.4096 (127.5 = random).
  Monte Carlo value for Pi is 3.145894608 (error 0.14 percent).
  Serial correlation coefficient is -0.001390 (totally uncorrelated = 0.0).

dieharder -a -f ../tmp/run.last                                  # runs 84-88 #
#=============================================================================#
#            dieharder version 3.31.1 Copyright 2003 Robert G. Brown          #
#=============================================================================#
   rng_name    |           filename             |rands/second|
        mt19937|                 ../tmp/run.last|  1.21e+08  |
#=============================================================================#
        test_name   |ntup| tsamples |psamples|  p-value |Assessment
#=============================================================================#
      rgb_lagged_sum|  15|   1000000|     100|0.99684604|   WEAK
      rgb_lagged_sum|  18|   1000000|     100|0.99957358|   WEAK

dieharder -a -f ../tmp/run.last                          # echo >> runs 84-88 #
#=============================================================================#
#            dieharder version 3.31.1 Copyright 2003 Robert G. Brown          #
#=============================================================================#
   rng_name    |           filename             |rands/second|
        mt19937|                 ../tmp/run.last|  1.20e+08  |
#=============================================================================#
        test_name   |ntup| tsamples |psamples|  p-value |Assessment
#=============================================================================#
         sts_monobit|   1|    100000|     100|0.99870841|   WEAK
         rgb_bitdist|   1|    100000|     100|0.99993470|   WEAK
    rgb_permutations|   5|    100000|     100|0.99511756|   WEAK
      rgb_lagged_sum|  28|   1000000|     100|0.00370196|   WEAK


--------------------------------------------------------------------------------  # run.89

  h1() { hg | pc -1 | bh | ./prpx -r1 -x1 | ud ibs=64; }

  h9() { { h1 & h1 & h1 & h1; } | ud obs=256 | pc -9; }

  hx() { h9 | ./prpx -r$1 -x$2  | ud ibs=256; }

  cg() { { hx 1 1  & hx -1 1 & hx 1 -1 & hx -1 -1; } | ud obs=1024; }

  Entropy = 7.999646 bits per byte.
  Chi square distribution for 506880 samples is 248.61, and randomly
  would exceed this value 60.10 percent of the times.
  Arithmetic mean value of data bytes is 127.4891 (127.5 = random).
  Monte Carlo value for Pi is 3.131865530 (error 0.31 percent).
  Serial correlation coefficient is -0.000099 (totally uncorrelated = 0.0).

--------------------------------------------------------------------------------  # run.90

  h1() { hg | pc -1 | bh | ./prpx -r$1 -x$2 | ud ibs=64; }

  h9() { { h1 1 1 & h1 -1 1 & h1 1 -1 & h1 -1 -1; } | ud obs=256; }

  hx() { h9 | pc -9 |      ./prpx -r$1 -x$2 | ud ibs=256; }

  cg() { { hx 1 1 & hx -1 1 & hx 1 -1 & hx -1 -1; } | ud obs=1k; }

  Entropy = 7.999592 bits per byte.
  Chi square distribution for 368640 samples is 208.12, and randomly
  would exceed this value 98.57 percent of the times.
  Arithmetic mean value of data bytes is 127.6366 (127.5 = random).
  Monte Carlo value for Pi is 3.141861979 (error 0.01 percent).
  Serial correlation coefficient is -0.002369 (totally uncorrelated = 0.0).

--------------------------------------------------------------------------------  # run.91

  h1() { hg | pc -1 | bh | ./prpx -r$1 -x$2; }

  h9() { { h1 1 1 & h1 -1 1 & h1 1 -1 & h1 -1 -1; } | ud ibs=2 obs=256; }

  hx() { h9 | pc -9 |      ./prpx -r$1 -x$2; }

  cg() { { hx 1 1 & hx -1 1 & hx 1 -1 & hx -1 -1; } | ud ibs=2 obs=1k; }

  Entropy = 7.999810 bits per byte.
  Chi square distribution for 1169408 samples is 307.33, and randomly
  would exceed this value 1.37 percent of the times.
  Arithmetic mean value of data bytes is 127.5309 (127.5 = random).
  Monte Carlo value for Pi is 3.139501593 (error 0.07 percent).
  Serial correlation coefficient is -0.000449 (totally uncorrelated = 0.0).

================================================================================
--------------------------------------------------------------------------------  # run.92

  pn() { nice -n19 ionice -c3 stdbuf -o0 -e0 -i0 "$@"; }

  pc() { pigz -cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  dg() { pn dd bs=2 "$@" 2>&1; }

  ud() { dg status=none "$@"; }

  bh() { sha512sum | xxd -r -p; }

  hg() { { time date +%N | dg; } 2>&1 | dg; }

  h1() { hg |  bh   | ./prpx -r$1 -x$2; }

  h9() { { h1 1 1 & h1 -1 1 & h1 1 -1 & h1 -1 -1; } | ud; }

  hx() { h9 | pc -9 | ./prpx -r$1 -x$2; }

  cg() { { hx 1 1 & hx -1 1 & hx 1 -1 & hx -1 -1; } | ud obs=1k; }

  Entropy = 7.999694 bits per byte.
  Chi square distribution for 598016 samples is 253.75, and randomly
  would exceed this value 51.03 percent of the times.
  Arithmetic mean value of data bytes is 127.4858 (127.5 = random).
  Monte Carlo value for Pi is 3.136180758 (error 0.17 percent).
  Serial correlation coefficient is -0.000089 (totally uncorrelated = 0.0).

--------------------------------------------------------------------------------  # run.93

  hx() { h9 | pc -1 | ./prpx -r$1 -x$2; }

  Entropy = 7.999336 bits per byte.
  Chi square distribution for 259072 samples is 238.63, and randomly
  would exceed this value 76.15 percent of the times.
  Arithmetic mean value of data bytes is 127.4833 (127.5 = random).
  Monte Carlo value for Pi is 3.137523739 (error 0.13 percent).
  Serial correlation coefficient is 0.000207 (totally uncorrelated = 0.0).

  Entropy = 7.999683 bits per byte.
  Chi square distribution for 607232 samples is 266.91, and randomly
  would exceed this value 29.16 percent of the times.
  Arithmetic mean value of data bytes is 127.5180 (127.5 = random).
  Monte Carlo value for Pi is 3.137275826 (error 0.14 percent).
  Serial correlation coefficient is 0.001493 (totally uncorrelated = 0.0).

--------------------------------------------------------------------------------  # run.94

  hx() { h9 | pc -9 -J4 | ./prpx -r$1 -x$2; }

  Entropy = 7.999463 bits per byte.
  Chi square distribution for 391168 samples is 291.42, and randomly
  would exceed this value 5.81 percent of the times.
  Arithmetic mean value of data bytes is 127.5399 (127.5 = random).
  Monte Carlo value for Pi is 3.142620487 (error 0.03 percent).
  Serial correlation coefficient is -0.002493 (totally uncorrelated = 0.0).

--------------------------------------------------------------------------------  # run.95

  hx() { h9 | pc -J4 | ./prpx -r$1 -x$2; }

Entropy = 7.998970 bits per byte.
Chi square distribution for 159744 samples is 228.06, and randomly
would exceed this value 88.65 percent of the times.
Arithmetic mean value of data bytes is 127.5147 (127.5 = random).
Monte Carlo value for Pi is 3.131460337 (error 0.32 percent).
Serial correlation coefficient is -0.000363 (totally uncorrelated = 0.0).

Entropy = 7.999430 bits per byte.
Chi square distribution for 306176 samples is 242.16, and randomly
would exceed this value 70.83 percent of the times.
Arithmetic mean value of data bytes is 127.3991 (127.5 = random).
Monte Carlo value for Pi is 3.139548100 (error 0.07 percent).
Serial correlation coefficient is 0.000406 (totally uncorrelated = 0.0).

--------------------------------------------------------------------------------  # run.96

  pc() { pigz -cp4 -J4 "$@" | tail -c+16 | head -c-8; }

  hx() { h9 | pc | ./prpx -r$1 -x$2; }

  Entropy = 7.999799 bits per byte.
  Chi square distribution for 1015808 samples is 283.72, and randomly
  would exceed this value 10.45 percent of the times.
  Arithmetic mean value of data bytes is 127.5984 (127.5 = random).
  Monte Carlo value for Pi is 3.140347665 (error 0.04 percent).
  Serial correlation coefficient is 0.000677 (totally uncorrelated = 0.0).

--------------------------------------------------------------------------------  # run.97

  hx() { h9 | pc -9 | ./prpx -r$1 -x$2; }

  Entropy = 7.999799 bits per byte.
  Chi square distribution for 1015808 samples is 283.72, and randomly
  would exceed this value 10.45 percent of the times.
  Arithmetic mean value of data bytes is 127.5984 (127.5 = random).
  Monte Carlo value for Pi is 3.140347665 (error 0.04 percent).
  Serial correlation coefficient is 0.000677 (totally uncorrelated = 0.0).

--------------------------------------------------------------------------------  # run.98

  pc() { pigz -qOcp4 "$@" | tail -c+16 | head -c-8; }

  hx() { h9 | pc -9 | ./prpx -r$1 -x$2; }

  Entropy = 7.999006 bits per byte.
  Chi square distribution for 205824 samples is 283.30, and randomly
  would exceed this value 10.77 percent of the times.
  Arithmetic mean value of data bytes is 127.6369 (127.5 = random).
  Monte Carlo value for Pi is 3.140741604 (error 0.03 percent).
  Serial correlation coefficient is 0.000223 (totally uncorrelated = 0.0).

--------------------------------------------------------------------------------  # run.99

  pc() { pigz -qcp4 -J4 -FI4 "$@" | tail -c+16 | head -c-8; }

  hx() { h9 | pc -9 | ./prpx -r$1 -x$2; }

  Entropy = 7.999136 bits per byte.
  Chi square distribution for 256000 samples is 306.50, and randomly
  would exceed this value 1.49 percent of the times.
  Arithmetic mean value of data bytes is 127.2226 (127.5 = random).
  Monte Carlo value for Pi is 3.153893030 (error 0.39 percent).
  Serial correlation coefficient is 0.001572 (totally uncorrelated = 0.0).

--------------------------------------------------------------------------------  # run.100

  pc() { pigz -qcp4 -J4 -I8 "$@" | tail -c+16 | head -c-8; }

  Entropy = 7.999387 bits per byte.
  Chi square distribution for 262144 samples is 222.81, and randomly
  would exceed this value 92.79 percent of the times.
  Arithmetic mean value of data bytes is 127.6152 (127.5 = random).
  Monte Carlo value for Pi is 3.148180362 (error 0.21 percent).
  Serial correlation coefficient is 0.002801 (totally uncorrelated = 0.0).

  Entropy = 7.999614 bits per byte.
  Chi square distribution for 414720 samples is 221.90, and randomly
  would exceed this value 93.38 percent of the times.
  Arithmetic mean value of data bytes is 127.6295 (127.5 = random).
  Monte Carlo value for Pi is 3.143923611 (error 0.07 percent).
  Serial correlation coefficient is 0.001241 (totally uncorrelated = 0.0).

--------------------------------------------------------------------------------  # run.101

  pc() { pigz -9qcp4 -J4 -I16 "$@" | tail -c+16 | head -c-8; }

  hx() { h9 | pc | ./prpx -r$1 -x$2; }

  Entropy = 7.997428 bits per byte.
  Chi square distribution for 60416 samples is 215.33, and randomly
  would exceed this value 96.62 percent of the times.
  Arithmetic mean value of data bytes is 127.5730 (127.5 = random).
  Monte Carlo value for Pi is 3.121660542 (error 0.63 percent).
  Serial correlation coefficient is -0.002250 (totally uncorrelated = 0.0).

  Entropy = 7.999086 bits per byte.
  Chi square distribution for 187392 samples is 237.77, and randomly
  would exceed this value 77.38 percent of the times.
  Arithmetic mean value of data bytes is 127.2651 (127.5 = random).
  Monte Carlo value for Pi is 3.135117828 (error 0.21 percent).
  Serial correlation coefficient is -0.001563 (totally uncorrelated = 0.0).

--------------------------------------------------------------------------------  # run.102

  pc() { pigz -9qcp8 -J4 -I16 "$@" | tail -c+16 | head -c-8; }

  hx() { h9 | pc | ./prpx -r$1 -x$2; }

  Entropy = 7.998967 bits per byte.
  Chi square distribution for 159744 samples is 228.72, and randomly
  would exceed this value 88.03 percent of the times.
  Arithmetic mean value of data bytes is 127.3838 (127.5 = random).
  Monte Carlo value for Pi is 3.140775240 (error 0.03 percent).
  Serial correlation coefficient is 0.000615 (totally uncorrelated = 0.0).

  Entropy = 7.999475 bits per byte.
  Chi square distribution for 362496 samples is 263.40, and randomly
  would exceed this value 34.55 percent of the times.
  Arithmetic mean value of data bytes is 127.5703 (127.5 = random).
  Monte Carlo value for Pi is 3.133474576 (error 0.26 percent).
  Serial correlation coefficient is -0.000974 (totally uncorrelated = 0.0).

  Entropy = 7.999936 bits per byte.
  Chi square distribution for 2772992 samples is 244.81, and randomly
  would exceed this value 66.56 percent of the times.
  Arithmetic mean value of data bytes is 127.5184 (127.5 = random).
  Monte Carlo value for Pi is 3.136767172 (error 0.15 percent).
  Serial correlation coefficient is -0.000312 (totally uncorrelated = 0.0).

# no ending echo                                                              #
#=============================================================================#
#            dieharder version 3.31.1 Copyright 2003 Robert G. Brown          #
#=============================================================================#
   rng_name    |           filename             |rands/second|
        mt19937|                    run.131.test|  9.29e+07  |
#=============================================================================#
        test_name   |ntup| tsamples |psamples|  p-value |Assessment
#=============================================================================#
       diehard_craps|   0|    200000|     100|0.99715571|   WEAK
          sts_serial|  16|    100000|     100|0.99977128|   WEAK
         rgb_bitdist|   3|    100000|     100|0.99902435|   WEAK
      rgb_lagged_sum|  14|   1000000|     100|0.99682434|   WEAK
      rgb_lagged_sum|  16|   1000000|     100|0.99657115|   WEAK
      rgb_lagged_sum|  17|   1000000|     100|0.99860941|   WEAK

--------------------------------------------------------------------------------  # run.103

  pn() { nice -n19 ionice -c3 stdbuf -o0 -e0 -i0 "$@"; }

  pc() { pigz -9cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  dg() { pn dd bs=2 "$@" 2>&1; }

  ud() { dg status=none "$@"; }

  bh() { sha512sum | xxd -r -p; }

  hg() { { time date +%N | dg; } 2>&1 | dg; }

  h1() { hg | bh | ./prpx -r ${1} -x ${2}; }

  h9() { { h1 -1 -1 & h1 1 -1 & h1 -1 -1 & h1 1 -1; } | ud; }

  hx() { h9 | pc | ./prpr -r${1}6 -o${2}5; }

  cg() { { hx -1 -1 & hx 1 -1 & hx -1 -1 & hx 1 -1; } | ud obs=1k; }

  Entropy = 7.999546 bits per byte.
  Chi square distribution for 360960 samples is 227.57, and randomly
  would exceed this value 89.09 percent of the times.
  Arithmetic mean value of data bytes is 127.4896 (127.5 = random).
  Monte Carlo value for Pi is 3.148736702 (error 0.23 percent).
  Serial correlation coefficient is 0.001691 (totally uncorrelated = 0.0).

  Entropy = 7.999899 bits per byte.
  Chi square distribution for 2004480 samples is 280.17, and randomly
  would exceed this value 13.36 percent of the times.
  Arithmetic mean value of data bytes is 127.4942 (127.5 = random).
  Monte Carlo value for Pi is 3.140241858 (error 0.04 percent).
  Serial correlation coefficient is 0.000167 (totally uncorrelated = 0.0).

--------------------------------------------------------------------------------

# runs: 83-102 (no ending echo)
#=============================================================================#
#            dieharder version 3.31.1 Copyright 2003 Robert G. Brown          #
#=============================================================================#
   rng_name    |           filename             |rands/second|
        mt19937|                         run.all|  1.19e+08  |
#=============================================================================#
        test_name   |ntup| tsamples |psamples|  p-value |Assessment
#=============================================================================#
     diehard_squeeze|   0|    100000|     100|0.00203685|   WEAK
      rgb_lagged_sum|  18|   1000000|     100|0.99885342|   WEAK

================================================================================
--------------------------------------------------------------------------------  # run.104

  pn() { nice -n19 ionice -c3 stdbuf -o0 -e0 -i0 "$@"; }

  pc() { pigz -9cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  dg() { ( pn time dd bs=2 "$@" ) 2>&1; }

  ud() { dg status=none "$@"; }

  bh() { sha512sum | xxd -r -p; }

  hg() { { time date +%N | dg; } 2>&1 | dg; }

  h1() { { hg & hg; } | bh | ./prpx -r ${1} -x ${2}; }

  h9() { { h1 -1 -1 & h1 1 -1 & h1 -1 -1 & h1 1 -1; } | ud; }

  hx() { h9 | pc | ./prpr -r${1}6 -o${2}5 | ./prpx -r-15 -x0; }

  cg() { { hx -1 -1 & hx 1 -1 & hx -1 -1 & hx 1 -1; } | ud obs=1k; }

  Entropy = 7.999574 bits per byte.
  Chi square distribution for 397440 samples is 234.72, and randomly
  would exceed this value 81.41 percent of the times.
  Arithmetic mean value of data bytes is 127.4860 (127.5 = random).
  Monte Carlo value for Pi is 3.134480676 (error 0.23 percent).
  Serial correlation coefficient is -0.000241 (totally uncorrelated = 0.0).

--------------------------------------------------------------------------------  # run.105

  dg() { pn dd bs=2 "$@"; }

  hg() { { time date +%N | dg; } 2>&1; }

  h1() { { hg & hg; } | bh | ./prpx -r ${1} -x ${2}; }

  Entropy = 7.999503 bits per byte.
  Chi square distribution for 338880 samples is 233.48, and randomly
  would exceed this value 82.93 percent of the times.
  Arithmetic mean value of data bytes is 127.6434 (127.5 = random).
  Monte Carlo value for Pi is 3.138526912 (error 0.10 percent).
  Serial correlation coefficient is 0.001239 (totally uncorrelated = 0.0).

  Entropy = 7.999852 bits per byte.
  Chi square distribution for 1225920 samples is 251.89, and randomly
  would exceed this value 54.32 percent of the times.
  Arithmetic mean value of data bytes is 127.5348 (127.5 = random).
  Monte Carlo value for Pi is 3.140759593 (error 0.03 percent).
  Serial correlation coefficient is -0.001990 (totally uncorrelated = 0.0).

--------------------------------------------------------------------------------  # run.106

  h1() { { hg & hg & hg & hg; } | bh | ./prpx -r ${1} -x ${2}; }

  pc() { pigz -1cp$(nproc) "$@" | tail -c+16 | head -c-8; }

  Entropy = 7.999495 bits per byte.
  Chi square distribution for 372480 samples is 260.61, and randomly
  would exceed this value 39.12 percent of the times.
  Arithmetic mean value of data bytes is 127.6209 (127.5 = random).
  Monte Carlo value for Pi is 3.144909794 (error 0.11 percent).
  Serial correlation coefficient is 0.000050 (totally uncorrelated = 0.0).

================================================================================
--------------------------------------------------------------------------------  # run.107

  pn() { nice -n19 ionice -c3 stdbuf -o0 -e0 -i0 "$@"; }

  pc() { pigz -1cp$(nproc) "$@" | tail -c+16 | head -c-8; }                         # workload -1

  sl() {  sleep 0.001; }

  dg() { pn dd bs=2 "$@"; }                                                         # semplificato

  ud() { dg status=none "$@"; }

  bh() { sha512sum | xxd -r -p; }

  hg() { { time date +%N | dg; } 2>&1; }                                            # semplificato

  h1() { { hg & hg & sl; } | bh | ./prpx -r ${1:-1} -x ${2:-1}; }                   # sleep 0.01

  h9() { { h1 -1 -1 & h1 1 -1 & h1 -1 -1 & h1 1 -1 & sl; } | ud; }                  # sleep 0.01

  hx() { h9 | pc | ./prpr -r${1:-1}6 -o${2:-1}5 | ./prpx -r-3 -x0; }

  cg() { { hx -1 -1 & hx 1 -1 & hx -1 -1 & hx 1 -1 & sl; } | ud obs=1k; }           # sleep 0.01

  # sleep 0.001
  Entropy = 7.999655 bits per byte.
  Chi square distribution for 521280 samples is 249.10, and randomly
  would exceed this value 59.25 percent of the times.
  Arithmetic mean value of data bytes is 127.6753 (127.5 = random).
  Monte Carlo value for Pi is 3.139364641 (error 0.07 percent).
  Serial correlation coefficient is -0.000840 (totally uncorrelated = 0.0).

  # sleep 0.01
  Entropy = 7.999661 bits per byte.
  Chi square distribution for 523200 samples is 245.54, and randomly
  would exceed this value 65.34 percent of the times.
  Arithmetic mean value of data bytes is 127.3580 (127.5 = random).
  Monte Carlo value for Pi is 3.145642202 (error 0.13 percent).
  Serial correlation coefficient is 0.001609 (totally uncorrelated = 0.0).

--------------------------------------------------------------------------------

rm -f run.all;
cat run.2 run.4 run.3 run.4 run.5 >> run.all;
echo >> run.all; du -ks run.all
dieharder -a -f run.all
#=============================================================================#
#            dieharder version 3.31.1 Copyright 2003 Robert G. Brown          #
#=============================================================================#
   rng_name    |           filename             |rands/second|
        mt19937|                         run.all|  9.89e+07  |
#=============================================================================#
        test_name   |ntup| tsamples |psamples|  p-value |Assessment
#=============================================================================#
        diehard_sums|   0|       100|     100|0.00016367|   WEAK

